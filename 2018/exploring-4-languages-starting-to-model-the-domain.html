<!DOCTYPE html>
<html lang="en">
<head>
    <title>Exploring 4 Languages: Starting to Model the Domain &middot; Chris Krycho</title>
    <meta name="description" content="Using the type systems of Rust, Elm, F♯, and ReasonML to encode the elements of a domain model—and starting to get some idea how the languages are like and unlike each other."/>

    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel='me' href='https://alpha.app.net/chriskrycho' data-type='follow' data-user-id='@chriskrycho'/>    <meta property="og:url" content="http://v4.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html"/>
    <meta property="og:title" content="Exploring 4 Languages: Starting to Model the Domain"/>
    <meta property="og:description" content="Using the type systems of Rust, Elm, F♯, and ReasonML to encode the elements of a domain model—and starting to get some idea how the languages are like and unlike each other."/>
        <meta property="og:image" content="http://v4.chriskrycho.com//assets/images/ck.png"/>
<link rel="author" href=""/>
<link rel="me" href=""/><meta name="twitter:card" content="summary"/>
<meta name="twitter:site" content="@chriskrycho"/>
<meta name="twitter:creator" content="@chriskrycho"/>
    <meta name="twitter:title" content="Exploring 4 Languages: Starting to Model the Domain"/>
    <meta name="twitter:description" content="Using the type systems of Rust, Elm, F♯, and ReasonML to encode the elements of a domain model—and starting to get some idea how the languages are like and unlike each other."/>
        <meta name="twitter:image" content="http://v4.chriskrycho.com/assets/images/ck.png"/>
    <link rel="me" href="http://stackoverflow.com/users/564181/chris-krycho"/>
    <link rel="me" href="https://github.com/chriskrycho"/>
    <link rel="me" href="https://patreon.com/chriskrycho"/>
    <link rel="me" href="https://soundcloud.com/chriskrycho"/>
    <link rel="me" href="https://vimeo.com/chriskrycho"/>
    <link rel="me" href="https://cash.me/$chriskrycho"/>
    <link rel="me" href="https://twitter.com/chriskrycho"/>
    <link rel="me" href="mailto:chris at chriskrycho dot com"/>
    <link rel="me" href="http://www.linkedin.com/in/chriskrycho"/>

    <link rel="openid.delegate" href="http://v4.chriskrycho.com/" />
    <link rel="openid.server" href="https://indieauth.com/openid" />

    <link rel="stylesheet" type="text/css" href="/assets/fonts.css"/>
    <link rel="stylesheet" type="text/css" href="/assets/style.css"/>
    <link rel="stylesheet" type="text/css" href="/assets/archival.css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel='stylesheet' href='//cdn.jsdelivr.net/font-hack/2.020/css/hack.min.css'>

    <link href="/favicon.png" type="image/png" rel="icon" />
    <link href="/favicon.ico" type="image/ico" rel="icon" />

    <script type="text/javascript" src="/assets/js/mtiFontTrackingCode.js"></script>


    <link rel="alternate" href="/feed.xml" type="application/rss+xml" title="All posts">
        <link rel="alternate" href="/feeds/Art.xml" type="application/rss+xml" title="Posts filed in in 'Art''">
        <link rel="alternate" href="/feeds/Blog.xml" type="application/rss+xml" title="Posts filed in in 'Blog''">
        <link rel="alternate" href="/feeds/Tech.xml" type="application/rss+xml" title="Posts filed in in 'Tech''">
        <link rel="alternate" href="/feeds/Theology.xml" type="application/rss+xml" title="Posts filed in in 'Theology''">
</head>
<body>
    <div id="archival-notice">This version of the site is now archived. See the current version at <a href="https://v5.chriskrycho.com">v5.chriskrycho.com</a></div>
    <header id="site-header">
        <div class="hgroup">
            <h1 id="site-title">
<a href="http://v4.chriskrycho.com"><img class="logotype" src="/assets/images/ck.png" alt="ck"/>Chris Krycho</a>
</h1>

            <h2 id="site-subtitle">Theology, technology, life & art</h2>
        </div>

        <nav>
            <ul>
                <li class="section-title"><a href="http://v4.chriskrycho.com/art/">Art</a></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/tech/">Tech</a></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/theology/">Theology</a></li>
                <li class="section-title divider" role="presentation"></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/series.html">Series</a></li>
                <li class="section-title divider" role="presentation"></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/about">About</a></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/cv">C.V.</a></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/now">Now</a></li>
            </ul>
        </nav>

    </header>


<article class="functional-programming rust elm fsharp reasonml domain-driven-design four-languages tech">

    <header>
<h1>Exploring 4 Languages: Starting to Model the Domain</h1>
<h2>How we use types to capture business concepts in Rust, Elm, F<sup>♯</sup>, and ReasonML.</h2>    </header>

    <div class="meta">
<span class="date"><a href="http://v4.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html" title="Exploring 4 Languages: Starting to Model the Domain"><i class="fa fa-fw fa-link"></i></a>January 14, 2018</span><span class="section">Filed under <a class="section-title" href="http://v4.chriskrycho.com/tech/">Tech</a></span><span class="hashtag"><a class="hashtags" href="http://v4.chriskrycho.com/domain-driven-design/">#domain-driven design</a><a class="hashtags" href="http://v4.chriskrycho.com/elm/">#elm</a><a class="hashtags" href="http://v4.chriskrycho.com/four-languages/">#four-languages</a><a class="hashtags" href="http://v4.chriskrycho.com/fsharp/">#fsharp</a><a class="hashtags" href="http://v4.chriskrycho.com/functional-programming/">#functional programming</a><a class="hashtags" href="http://v4.chriskrycho.com/reasonml/">#reasonml</a><a class="hashtags" href="http://v4.chriskrycho.com/rust/">#rust</a></span><span><a href="http://v4.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.txt">Markdown source</a></span>    </div>

    <div class="content-wrapper">


        <div class="content">

<p>In the first three chapters of <em>Domain Modeling Made Functional</em>, Wlaschin walks through the creation of a “domain model” for an order-taking system. (It’s well worth reading the book just for a bunch of the lessons in that section—I found them quite helpful!) Then, after spending a chapter introducing F<sup>♯</sup>’s type system, he introduces the ways you can <em>use</em> those type mechanics to express the domain. In today’s post, I’ll show the idiomatic implementations of these types in each of Rust, Elm, F<sup>♯</sup>, and ReasonML.</p>
<section id="simple-values" class="level2">
<h2>Simple values</h2>
<p>Simple wrapper types let you take simple types like strings, numbers, etc. and use types to represent part of the business domain you’re dealing with—the basic idea being that a Customer ID may be a number, but it’s not interchangeable with <em>other</em> numbers such as Order IDs.</p>
<p>Here’s the most ergonomic and effective (and automatically-formatted in line with the language standards, where applicable!) way to do that in each of the languages:</p>
<p>Rust:</p>
<pre class="rust"><code>struct CustomerId(i32);</code></pre>
<p>Elm:</p>
<pre class="elm"><code>type CustomerId
    = CustomerId Int</code></pre>
<p>F<sup>♯</sup>:</p>
<pre class="fsharp"><code>type CustomerId = CustomerId of int</code></pre>
<p>ReasonML:</p>
<pre class="reason"><code>type customerId =
  | CustomerId(int);</code></pre>
<p>Note how similar these all are! The Rust implementation is the <em>most</em> distinctive, though you can do it with the same kind of union type as the others. Here’s how that would look:</p>
<pre class="rust"><code>enum CustomerId {
  CustomerId(i32),
}</code></pre>
<p>For performance reasons, you might also choose to implement the F<sup>♯</sup> type as a struct:</p>
<pre class="fsharp"><code>&lt;Struct&gt;
type CustomerId = CustomerId of int</code></pre>
</section>
<section id="complex-data" class="level2">
<h2>Complex data</h2>
<p>Wlaschin then moves on to showing how to model more complex data structures: types that “and” or “or” together other data. We “and” data together using record or struct types, and “or” data together using “union” or “enum” types. (Assume we’ve defined <code>CustomerInfo</code>, <code>ShippingAddress</code>, etc. types for all of these.)</p>
<p>Rust:</p>
<pre class="rust"><code>// &quot;and&quot;
struct Order {
    customer_info: CustomerInfo,
    shipping_address: ShippingAddress,
    billing_address: BillingAddress,
    order_lines: Vec&lt;OrderLine&gt;,
    billing_amount: BillingAmount,
}

// &quot;or&quot;
enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}</code></pre>
<p>Elm:</p>
<pre class="elm"><code>-- &quot;and&quot;
type alias Order =
    { customerInfo : CustomerInfo
    , shippingAddress : ShippingAddress
    , billingAddress : BillingAddress
    , orderLines : List OrderLine
    , billingAmount : BillingAmount
    }

-- &quot;or&quot;
type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode</code></pre>
<p>F<sup>♯</sup>:</p>
<pre class="fsharp"><code>// &quot;and&quot;
type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill: BillingAmount
}

// &quot;or&quot;
type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode</code></pre>
<p>ReasonML—note that since we’re assuming we’ve already defined the other types here, you can write this without duplicating the name and type declaration, just like you can with JavaScript object properties.</p>
<pre class="reason"><code>/* &quot;and&quot; */
type order = {
  customerInfo,
  shippingAddress,
  billingAddress,
  orderLine,
  billingAmount
};

/* &quot;or&quot; */
type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);</code></pre>
<p>An interesting aside: unless you planned to reuse these types, you wouldn’t usually write these as standalone types with this many wrapper types in it in Rust in particular (even if the compiler would often recognize that it could squash them down for you).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Instead, you’d normally write <em>only</em> the base enum type to start, and refactor out the <code>struct</code> wrapper later only if you found you needed it elsewhere:</p>
<pre class="diff"><code>enum ProductCode {
-    Widget(WidgetCode),
+    Widget(String),
-    Gizmo(GizmoCode),
+    Gizmo(String),
}</code></pre>
<p>That said: given how the book is tackling things, and the fact that you might want to <em>validate</em> these types… having them as these low-cost wrappers is probably worth it. (In fact, having read a bit further than I’ve managed to write out yet, I can guarantee it.)</p>
<p>We work through the rest of the basic types this way. But what about the types where we don’t yet have a good idea how we want to handle them?</p>
<p>Each of these languages gives us an out (or more than one) for how to say “I don’t know what to put here yet.”</p>
<p>Rust (which does not have a built-in <code>Never</code> type… yet; see below):</p>
<pre class="rust"><code>// Make an empty enum (which you by definition cannot construct)
enum Never {}

// Use it throughout where we don&#39;t know the type yet. It will fail to compile
// anywhere we try to *use* this, because you can&#39;t construct it.
type OrderId = Never;</code></pre>
<p>Elm (which has a built-in <code>Never</code> type):</p>
<pre class="elm"><code>-- It will fail to compile anywhere we try to *use* this, because you cannot
-- construct `Never`.
type alias OrderId =
    Never</code></pre>
<p>F<sup>♯</sup> (which <em>sort</em> of does):</p>
<pre class="fsharp"><code>// Make a convenience type for the `exn`/`System.Exception` type
type Undefined = exn

type OrderId = Undefined</code></pre>
<p>Reason (which also <em>sort</em> of does—identically with F<sup>♯</sup>):</p>
<pre class="reason"><code>/* Make a convenience type for the `exn`/`System.Exception` type */
type undefined = exn;

/*
  Use it throughout where we don&#39;t know the type yet. It will compile, but fail
  to run anywhere we try to *use* this.
 */
type orderId = undefined;</code></pre>
<p>For both F<sup>♯</sup> and Reason, that’s following Wlaschin’s example. The main reason to do that is to make explicit that we’re not actually wanting an <em>exception</em> type in our domain model, but just something we haven’t <em>yet</em> defined. Anywhere we attempted to use it, we’d have to handle it like, well… an exception, instead of an actual type.</p>
<pre class="rust"><code>type OrderId = !;</code></pre>
</section>
<section id="workflows-and-functions" class="level2">
<h2>Workflows and functions</h2>
<p>Once we have the basic types themselves in place, we need to write down the ways we transform between them. In a functional style, we’re not going to implement instance methods—though as we’ll see in the next post, what we do in Rust will have <em>some</em> similarities to class methods—we’re going to implement standalone functions which take types and return other types.</p>
<p>Again, you’ll note that despite the common lineage, there is a fair amount of variation here. (Note that we’d also have defined the <code>UnvalidatedOrder</code>, <code>ValidationError</code>, and <code>ValidatedOrder</code> types for all of this; I’m mostly interested in showing <em>new</em> differences here.)</p>
<p>Rust (using the <a href="https://github.com/alexcrichton/futures-rs">Futures</a> library to represent eventual computation):</p>
<pre class="rust"><code>type ValidationResponse&lt;T&gt; = Future&lt;Item = T, Error = ValidationError&gt;;

fn validate_order(unvalidated: UnvalidatedOrder) -&gt; Box&lt;ValidationResponse&lt;ValidatedOrder&gt;&gt; {
    unimplemented!()
}</code></pre>
<p>Elm (using the built-in <code>Task</code> type for eventual computation; <code>Task</code>s encapsulate both eventuality and the possibility of failure):</p>
<pre class="elm"><code>type ValidationResponse a
    = Task (List ValidationError) a

type alias ValidateOrder =
    UnvalidatedOrder -&gt; ValidationResponse ValidatedOrder</code></pre>
<p>F<sup>♯</sup> (using the built-in <code>Async</code> type for eventual computation):</p>
<pre class="fsharp"><code>type ValidationResponse&lt;&#39;a&gt; = Async&lt;Result&lt;&#39;a,ValidationError list&gt;&gt;

type ValidateOrder =
    UnvalidatedOrder -&gt; ValidationResponse&lt;ValidatedOrder&gt;</code></pre>
<p>Reason (using the built-in JavaScript-specific <code>Js.Promise</code> type—which is exactly what it sounds like—for eventual computation):</p>
<pre class="reason"><code>type validationResponse(&#39;a) = Js.Promise.t(Js.Result.t(&#39;a, list(validationError)));

type validateOrder = unvalidatedOrder =&gt; validationResponse(validatedOrder);</code></pre>
<p>Once again Rust is much <em>more</em> different here from the others than they are from each other. The biggest difference between Elm, F<sup>♯</sup>, and Reason is how they handle generics and type parameters.</p>
<p>You’ll note that in Elm, they just follow the name of the wrapping type. This is a kind of syntactic symmetry: the way you <em>name</em> a generic type like this is the same basic way you <em>construct</em> it. It’s quite elegant. And as it turns out, the same is true of Reason; it’s just that its authors have chosen to follow OCaml and use parentheses for them instead of following Haskell with spaces—a reasonable choice, given Reason is surface syntax for OCaml and not Haskell.</p>
<p>F<sup>♯</sup> uses angle brackets, I strongly suspect, because that’s what C<sup>#</sup> uses for generics, and keeping them syntactically aligned in things like this is very helpful. Rust similarly uses angle brackets for similarity with other languages which have similar surface syntax—especially C++ (with its templates).</p>
<p>The way you <em>name</em> generic parameters differs between the languages as well. Elm, following Haskell, uses lowercase letters to name its generics (usually called <em>type parameters</em> in Elm). F<sup>#</sup> and Reason both (unsurprisingly) follow OCaml in using lowercase letters preceded by an apostrophe to name generics—in F<sup>#</sup>, <code>TypeGenericOver&lt;'a&gt;</code>; in Reason, <code>typeGenericOver('a)</code>. Rust follows the convention from languages like C++, Java, and C<sup>#</sup> and uses capital letters, <code>TypeGenericOver&lt;T&gt;</code>. The use of specific letters is conventional, not mandated by the language (unlike the casing). The ML family usually starts with <code>a</code> and moves through the alphabet; Rust and the languages it follows usually start with <code>T</code> (for <em>type</em>) and moves forward through the alphabet. (Sometimes you’ll also see different letters where it’s obviously a better fit for what’s contained.)</p>
<p>These languages also vary in the syntax for constructing a <em>list</em> of things. In F<sup>#</sup> has convenience syntax for a few built-ins (the most common being the <code>List</code> and <code>Option</code> types), allowing you to write them <em>either</em> as e.g. <code>List&lt;ConcreteType&gt;</code> or <code>ConcreteType list</code> (as here in the example). Elm, Reason, and Rust all just use the standard syntax for generic types—<code>List a</code>, <code>list('a)</code>, and <code>Vec&lt;T&gt;</code> respectively.</p>
<p>Finally, you’ll also note that we haven’t written out a <em>type</em> declaration here for Rust; we’ve actually written out a stub of a function, with the <a href="https://doc.rust-lang.org/std/macro.unimplemented.html"><code>unimplemented!()</code></a> <a href="https://doc.rust-lang.org/1.17.0/reference/macros-by-example.html">macro</a>. If you invoke this function, you’ll get a clear crash with an explanation of which function isn’t implemented.</p>
<p>Now, Rust also <em>does</em> let us write out the type of these functions as type aliases if we want:</p>
<pre class="rust"><code>type ValidateOrder =
    Fn(UnvalidatedOrder) -&gt; Box&lt;ValidationResponse&lt;ValidatedOrder&gt;&gt;;</code></pre>
<p>You just don’t use these very often in idiomatic Rust; it’s much more conventional to simply write out what I did above. However, the one time you <em>might</em> use a type alias like this is when you’re defining the type of a closure and you don’t want to write it inline. This is a pretty sharp difference between Rust and the other languages on display here, and it goes to the difference in their approaches.</p>
<p>Rust is <em>not</em> a functional-first language in the way that each of the others are, though it certainly draws heavily on ideas from functional programming throughout and makes quite a few affordances for a functional style. Instead, it’s a programming language first and foremost interested in combining the most screaming performance possible with true safety, and leaning on ideas from the ML family (among others!) as part of achieving that.</p>
<p>Among other things, this is why you don’t have currying or partial application in Rust: those essentially <em>require</em> you to have invisible heap-allocation to be ergonomic. We <em>don’t</em> have that in Rust, as we do in Elm, Reason, and F<sup>♯</sup>. If we want to pass around a function, we have to explicitly wrap it in a pointer to hand it around if we construct it in another function. (I won’t go into more of the details of this here; I’ve covered it some <a href="http://www.newrustacean.com/show_notes/e004/index.html">on New Rustacean</a> and some <a href="http://v4.chriskrycho.com/2015/rust-and-swift-viii.html">in my Rust and Swift comparison</a> a couple years ago.)</p>
<p>That same underlying focus on performance and explicitness is the reason we have <code>Box&lt;ValidationResponse&lt;ValidatedOrder&gt;&gt;</code> in the Rust case: we’re explicitly returning a <em>pointer</em> to the type here. In Elm, F<sup>♯</sup>, and Reason, that’s <em>always</em> the case. But in Rust, you can and often do return stack-allocated data and rely on “move” semantics to copy or alias it properly under the hood.</p>
</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<p>So: lots of similarities here at first blush. The biggest differences that show up at this point are purely syntactical, other than some mildly sharper differences with Rust because of its focus on performance. The fact that these languages share a common lineage means it’s not hard to read any of them if you’re familiar with the others, and it’s actually quite easy to switch between them at the levels of both syntax and semantics.</p>
<p>As usual, when dealing with languages in a relatively similar family, it’s <em>most</em> difficult to learn the <em>library</em> differences. The most obvious example of that here is Reason’s <code>Js.Promise</code>, Elm’s <code>Task</code>, F<sup>♯</sup>’s <code>Async</code>, and Rust’s <code>Future</code> types: each of those has their own quirks, their own associated helper functions or methods, and their own ways of handling the same basic patterns.</p>
<p>Still, if you have played with any one of these, you could pretty easily pick up one of the others. It’s sort of like switching between Python and Ruby: there are some real differences there, but the similarities are greater than the differences. Indeed, if anything, these languages are <em>more</em> similar than those.</p>
<p>Next time I’ll dig into Wlaschin’s chapter on <em>validating</em> the domain model, and here some of the not-just-syntax-level differences in the languages will start to become more apparent.</p>
</section>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I can’t speak to what’s idiomatic this way in any of the non-Rust languages, because I just haven’t used them enough yet.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
        </div>
    </div>
</article>


    <footer id="site-footer"><section id="connect">
    <h2>Connect</h2>
    <ul class="icons">
        <li><a href="mailto:chris at chriskrycho dot com"><i class="fa fa-fw fa-envelope"></i>Email</a></li>
        <li><a href="https://github.com/chriskrycho"><i class="fa fa-fw fa-github"></i>GitHub</a></li>
        <li><a href="https://twitter.com/chriskrycho"><i class="fa fa-fw fa-twitter"></i>Twitter</a></li>
        <li><a href="https://soundcloud.com/chriskrycho"><i class="fa fa-fw fa-soundcloud"></i>SoundCloud</a></li>
        <li><a href="http://www.linkedin.com/in/chriskrycho"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a></li>
        <li><a href="https://vimeo.com/chriskrycho"><i class="fa fa-fw fa-vimeo"></i>Vimeo</a></li>
        <li><a href="http://stackoverflow.com/users/564181/chris-krycho"><i class="fa fa-fw fa-stack-overflow"></i>Stack Overflow</a></li>
    </ul>
    <h3>Support Me</h3>
    <ul class='icons'>
        <li><a href="https://patreon.com/chriskrycho"><i class='fa fa-fw fa-money'></i>Patreon</a></li>
        <li><a href="https://cash.me/$chriskrycho"><i class='fa fa-fw fa-usd'></i>Cash.me</a></li>
    </ul>
</section>
<section id="subscribe">
    <h2>Subscribe</h2>
    <ul class="icons">
        <li class="section-title">
            <a onclick="window.open('http://eepurl.com/GzswP', 'subscribe', 'width=608,height=608')">
                   <i class="fa fa-fw fa-envelope"></i>Email
            </a>
        </li>
    </ul>
    <h3>Feeds</h3>
    <ul class="icons">
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feed.xml"><i class="fa fa-fw fa-rss"></i>Everything</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Art.xml"><i class="fa fa-fw fa-rss"></i>Art</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Blog.xml"><i class="fa fa-fw fa-rss"></i>Blog</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Tech.xml"><i class="fa fa-fw fa-rss"></i>Tech</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Theology.xml"><i class="fa fa-fw fa-rss"></i>Theology</a>
        </li>
    </ul>
</section>
<section id="recent">
    <h2>Recent</h2>
    <ul>
        <li>Art: <a href="http://v4.chriskrycho.com/2019/photography-ing-again.html">Photography-ing Again!</a></li>
        <li>Blog: <a href="http://v4.chriskrycho.com/2019/sympolymathesy-or-v5chriskrychocom.html">Sympolymathesy, or: v5.chriskrycho.com
</a></li>
        <li>Tech: <a href="http://v4.chriskrycho.com/2019/test-the-interface.html">Test the Interface</a></li>
        <li>Theology: <a href="http://v4.chriskrycho.com/2019/review-what-is-an-evangelical.html">Review: <cite>What is an Evangelical</cite>
</a></li>
    </ul>
</section></footer>

    <script type="text/javascript">
    var MTIProjectId='a34d2e31-99b5-469a-9b81-128fc0bd9745';
    </script>

<link rel="stylesheet" href="/assets/tomorrow.min.css">
<script src="/assets/js/highlight.pack.js"></script>
<script type="text/javascript">
// Get all the <pre><code> elements, and use the <pre> element to set the <code>
// element's class so hljs will use it rather than trying to figure it out.
var preEls = document.getElementsByTagName('pre');
for (var e in preEls) {
    var pre = preEls[e];
    if (pre.firstChild && pre.firstChild.tagName === 'CODE') {
        var code = pre.firstChild;
        code.className = pre.className;
    }
}

// Then run hljs.
hljs.initHighlightingOnLoad();
</script>

<script type="text/javascript" src="/assets/js/lib.js"></script>
</body>
</html>