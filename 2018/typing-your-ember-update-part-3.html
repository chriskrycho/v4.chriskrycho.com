<!DOCTYPE html>
<html lang="en">
<head>
    <title>TypeScript and Ember.js Update, Part 3 &middot; Chris Krycho</title>
    <meta name="description" content="Now that we know a bit more about how computed properties work, we’ll talk about computed properties, actions, and mixins on the Ember.js side, along with the normal class methods."/>

    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel='me' href='https://alpha.app.net/chriskrycho' data-type='follow' data-user-id='@chriskrycho'/>    <meta property="og:url" content="http://v4.chriskrycho.com/2018/typing-your-ember-update-part-3.html"/>
    <meta property="og:title" content="TypeScript and Ember.js Update, Part 3"/>
    <meta property="og:description" content="Now that we know a bit more about how computed properties work, we’ll talk about computed properties, actions, and mixins on the Ember.js side, along with the normal class methods."/>
        <meta property="og:image" content="http://v4.chriskrycho.com//assets/images/ck.png"/>
<link rel="author" href=""/>
<link rel="me" href=""/><meta name="twitter:card" content="summary"/>
<meta name="twitter:site" content="@chriskrycho"/>
<meta name="twitter:creator" content="@chriskrycho"/>
    <meta name="twitter:title" content="TypeScript and Ember.js Update, Part 3"/>
    <meta name="twitter:description" content="Now that we know a bit more about how computed properties work, we’ll talk about computed properties, actions, and mixins on the Ember.js side, along with the normal class methods."/>
        <meta name="twitter:image" content="http://v4.chriskrycho.com/assets/images/ck.png"/>
    <link rel="me" href="http://stackoverflow.com/users/564181/chris-krycho"/>
    <link rel="me" href="https://github.com/chriskrycho"/>
    <link rel="me" href="https://patreon.com/chriskrycho"/>
    <link rel="me" href="https://soundcloud.com/chriskrycho"/>
    <link rel="me" href="https://vimeo.com/chriskrycho"/>
    <link rel="me" href="https://cash.me/$chriskrycho"/>
    <link rel="me" href="https://twitter.com/chriskrycho"/>
    <link rel="me" href="mailto:chris at chriskrycho dot com"/>
    <link rel="me" href="http://www.linkedin.com/in/chriskrycho"/>

    <link rel="openid.delegate" href="http://v4.chriskrycho.com/" />
    <link rel="openid.server" href="https://indieauth.com/openid" />

    <link rel="stylesheet" type="text/css" href="/assets/style.css"/>
    <link rel="stylesheet" type="text/css" href="/assets/fonts.css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel='stylesheet' href='//cdn.jsdelivr.net/font-hack/2.020/css/hack.min.css'>

    <link href="/favicon.png" type="image/png" rel="icon" />
    <link href="/favicon.ico" type="image/ico" rel="icon" />

    <script type="text/javascript" src="/assets/js/mtiFontTrackingCode.js"></script>


    <link rel="alternate" href="/feed.xml" type="application/rss+xml" title="All posts">
        <link rel="alternate" href="/feeds/Art.xml" type="application/rss+xml" title="Posts filed in in 'Art''">
        <link rel="alternate" href="/feeds/blog.xml" type="application/rss+xml" title="Posts filed in in 'Blog''">
        <link rel="alternate" href="/feeds/Tech.xml" type="application/rss+xml" title="Posts filed in in 'Tech''">
        <link rel="alternate" href="/feeds/Theology.xml" type="application/rss+xml" title="Posts filed in in 'Theology''">
</head>
<body>
    <header id="site-header">
        <div class="hgroup">
            <h1 id="site-title">
<a href="http://v4.chriskrycho.com"><img class="logotype" src="/assets/images/ck.png" alt="ck"/>Chris Krycho</a>
</h1>

            <h2 id="site-subtitle">Theology, technology, life & art</h2>
        </div>

        <nav>
            <ul>
                <li class="section-title art"><a href="http://v4.chriskrycho.com/art/">Art</a></li>
                <li class="section-title blog"><a href="http://v4.chriskrycho.com/blog/">blog</a></li>
                <li class="section-title tech"><a href="http://v4.chriskrycho.com/tech/">Tech</a></li>
                <li class="section-title theology"><a href="http://v4.chriskrycho.com/theology/">Theology</a></li>
                <li class="section-title divider" role="presentation"></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/series.html">Series</a></li>
                <li class="section-title divider" role="presentation"></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/about">About</a></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/cv">C.V.</a></li>
                <li class="section-title"><a href="http://v4.chriskrycho.com/now">Now</a></li>
            </ul>
        </nav>

    </header>


<article class="typescript emberjs typing-your-ember tech">

    <header>
<h1>TypeScript and Ember.js Update, Part 3</h1>
<h2>Computed properties, actions, mixins, and class methods.
</h2>    </header>

    <div class="meta">
<span class="date"><a href="http://v4.chriskrycho.com/2018/typing-your-ember-update-part-3.html" title="TypeScript and Ember.js Update, Part 3"><i class="fa fa-fw fa-link"></i></a>January 25, 2018 (updated July 10, 2018)</span><span class="section">Filed under <a class="section-title" href="http://v4.chriskrycho.com/tech/">Tech</a></span><span class="hashtag"><a class="hashtags" href="http://v4.chriskrycho.com/emberjs/">#emberjs</a><a class="hashtags" href="http://v4.chriskrycho.com/typescript/">#typescript</a><a class="hashtags" href="http://v4.chriskrycho.com/typing-your-ember/">#typing-your-ember</a></span><span><a href="http://v4.chriskrycho.com/2018/typing-your-ember-update-part-3.txt">Markdown source</a></span>    </div>

    <div class="content-wrapper">


        <div class="content">

<p><i class='series-overview'>You write <a href="https://emberjs.com">Ember.js</a> apps. You think <a href="http://www.typescriptlang.org">TypeScript</a> would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.</i></p>
<p><i class='series-overview'>This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.</i></p>
<p><i class='series-overview'><a href="/typing-your-ember.html">(See the rest of the series. →)</a></i></p>
<hr />
<p><strong>Note:</strong> if you’re following along with this <em>as I publish it</em> in late January 2018, please go back and read the end of <a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-2.html">Part 2</a>, which I updated substantially yesterday evening to include more material I missed in the first version of that post, but which belonged there and not here.</p>
<p>In the previous posts in this series, I introduced the big picture of how the story around TypeScript and Ember.js has improved over the last several months and walked through some important background on class properties. In this post, I’ll build on that foundation to look closely at computed properties, actions, and mixins.</p>
<aside>
<p>If you’re interested in all of this and would like to learn more in person, I’m <a href="http://emberconf.com/speakers.html#chris-krycho">leading a workshop on it at EmberConf 2018</a>—I’d love to see you there!</p>
</aside>
<p>Here’s the outline of this update sequence:</p>
<ol type="1">
<li><a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-1.html">Overview, normal Ember objects, component arguments, and injections.</a></li>
<li><a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-2.html">Class properties—some notes on how things differ from the <code>Ember.Object</code> world.</a></li>
<li><a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-3.html"><strong>Computed properties, actions, mixins, and class methods (this post).</strong></a></li>
<li><a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-4.html">Using Ember Data, and service and controller injections improvements.</a></li>
<li>Mixins and proxies; or: the really hard-to-type-check bits.</li>
</ol>
<section id="a-detailed-example-contd.-computed-properties-mixins-actions-and-class-methods" class="level2">
<h2>A detailed example (cont’d.) – computed properties, mixins, actions, and class methods</h2>
<aside>
<p>*<strong>Note:</strong> please see the <a href="https://v4.chriskrycho.com/2018/ember-ts-class-properties.html">update about class properties published mid-2018</a>. The example below and in the following posts is incorrect in several important ways.</p>
</aside>
<p>Let’s start by recalling the example Component we’re working through:</p>
<pre class="typescript"><code>import Component from &#39;@ember/component&#39;;
import { computed, get } from &#39;@ember/object&#39;;
import Computed from &#39;@ember/object/computed&#39;;
import { inject as service } from &#39;@ember/service&#39;;
import { assert } from &#39;@ember/debug&#39;;
import { isNone } from &#39;@ember/utils&#39;;

import Session from &#39;my-app/services/session&#39;;
import Person from &#39;my-app/models/person&#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  session: Computed&lt;Session&gt; = service();

  // -- Class properties -- //
  aString = &#39;this is fine&#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &#39;model.firstName&#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &#39;firstName&#39;)};`;
    }
  );

  aComputed = computed(&#39;aString&#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&#39;session.user&#39;);
  savedUser: Computed&lt;Person&gt; = alias(&#39;session.user&#39;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&#39;aCollection&#39;);
      this.set(&#39;aCollection&#39;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&#39;`model` is required&#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&#39;aCollection&#39;).includes(&#39;ahoy&#39;)) {
      this.set(&#39;aCollection&#39;, current.concat(&#39;ahoy&#39;));
    }
  }
}</code></pre>
<section id="computed-properties" class="level3">
<h3>Computed properties</h3>
<p>We already covered component arguments and injections as well as basic class properties and the exceptions to normal class-property ways of doing things, in Parts <a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-2.html">1</a> and <a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-2.html">2</a>. With that background out of the way, we can now turn to computed properties. I’m including the component arguments in this code sample because they’re referenced in the computed property. Assume <code>Person</code> is a pretty “person” representation, with a <code>firstName</code> and a <code>lastName</code>and maybe a few other properties.</p>
<pre class="typescript"><code>  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &#39;model.firstName&#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &#39;firstName&#39;)};`;
    }
  );

  aComputed = computed(&#39;aString&#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&#39;session.user&#39;);
  savedUser: Computed&lt;Person&gt; = alias(&#39;session.user&#39;);</code></pre>
<section id="computed-properties-1" class="level4">
<h4><code>computed</code> properties</h4>
<p>When using a computed property in the brave new world of ES6 classes, we normally just assign them as instance properties. As mentioned in <a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-2.html">the previous post</a>, and in line with my comments above, this has some important tradeoffs around performance. If you need the absolute <em>best</em> performance, you can continue to install them on the prototype by doing this instead:</p>
<pre class="typescript"><code>export default class MyComponent extends Component.extend({
  fromModel: computed(
    &#39;model.firstName&#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &#39;firstName&#39;)};`;
    }
  ),
}) {
  // other properties
}</code></pre>
<p>Whichever way you do it, TypeScript will correctly infer the type of the computed property in question (here <code>fromModel</code>) as long as you explicitly annotate the return type of the callback passed to <code>computed</code>. Accordingly, in this case, the type of <code>fromModel</code> is <code>ComputedProperty&lt;string&gt;</code>. The fact that it’s a <code>ComputedProperty</code> means if you try to treat it as a plain string, without using <code>Ember.get</code> to unwrap it, TypeScript will complain at you.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<pre class="typescript"><code>// type checking error:
this.fromModel.length;

// type checking valid:
this.get(&#39;fromModel&#39;).length;</code></pre>
<p>The other really important thing to note here is the use of <code>this: MyComputed</code>. By doing this, we’re telling TypeScript explicitly that the type of <code>this</code> in this particular function is the class context. We have to do this here, because we don’t have any way to tell the <code>computed</code> helper itself that the function inside it will be bound to the <code>this</code> context of the containing class. Put another way: we don’t have any <em>other</em> way to tell TypeScript that one of the things <code>computed</code> does is bind <code>this</code> appropriately to the function passed into it; but gladly we do have <em>this</em> way—otherwise we’d be out of luck entirely! (You’ll see the same thing below when we look at actions). The boilerplate is a bit annoying, admittedly—but it at least makes it type-check.</p>
</section>
<section id="computed-property-macros" class="level4">
<h4>Computed property macros</h4>
<p>Beyond <code>computed</code>, there are a lot of other computed property tools we use all the time. Some of them can (and therefore <em>do</em>) infer the type of the resulting computed property correctly. But there are a bunch of idiomatic things that TypeScript does not and cannot validate – a number of the computed property macros are in this bucket, because they tend to be used for nested keys, and as noted above, TypeScript does not and <em>cannot</em> validate nested keys like that.</p>
<p>We have a representative of each of these scenarios:</p>
<pre class="typescript"><code>  isLoggedIn = bool(&#39;session.user&#39;);
  savedUser: Computed&lt;Person&gt; = alias(&#39;session.user&#39;);</code></pre>
<p>In the case of <code>isLoggedIn</code>, the <code>bool</code> helper only ever returns a boolean, so the type of <code>isLoggedIn</code> is <code>ComputedProperty&lt;boolean&gt;</code>. In the case of <code>savedUser</code>, since TypeScript can’t figure out what the nested key means, we have to specify it explicitly, using <code>Computed&lt;Person&gt;</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> In these cases, you have to do the work yourself to check that the type you specify is the <em>correct</em> type. If you write down the wrong type here, TypeScript will believe you (it doesn’t have any other good option!) and you’ll be back to things blowing up unexpectedly at runtime.</p>
<p>The typings supply the concrete (non-<code>any</code>) return type for: <code>and</code>, <code>bool</code>, <code>equal</code>, <code>empty</code>, <code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code>, <code>match</code>, <code>map</code>, <code>max</code>, <code>min</code>, <code>notEmpty</code>, <code>none</code>, <code>not</code>, <code>or</code>, and <code>sum</code>.</p>
</section>
<section id="on-nested-keys" class="level4">
<h4>On nested keys</h4>
<p>As noted above, TypeScript cannot do a lookup for any place using nested keys—which means that <code>this.get('some.nested.key')</code> won’t type-check, sadly. This is an inherent limitation of the type system as it stands today, and for any future I can foresee. The problem is this: what exactly <em>is</em> <code>'some.nested.key'</code>? It <em>could</em> be what we use it for in the usual scenario in Ember, of course: a string representing a lookup on a property of a property of a property of whatever <code>this</code> is. But it could equally well be a key named <code>'some.nested.key'</code>. This is perfectly valid JavaScript, after all:</p>
<pre class="javascript"><code>const foo = {
  [&#39;some.nested.key&#39;]: &#39;Well, this is weird, but it works&#39;,
};</code></pre>
<p>TypeScript does not today and presumably <em>never will</em> be able to do that lookup. The workaround is to do one of two things:</p>
<ol type="1">
<li><p>If you <em>know</em> you have a valid parent, you can do the (catastrophically ugly, but functional) nested <code>Ember.get</code> that now litters our codebase:</p>
<pre class="typescript"><code>import { get } from &#39;@ember/object&#39;;
const value = get(get(get(anObject, &#39;some&#39;), &#39;nested&#39;), &#39;key&#39;);</code></pre>
<p>Yes, it’s a nightmare. But… it type-checks, and it works well <em>enough</em> in the interim until we get a decorators-based solution that lets us leverage <a href="https://github.com/emberjs/rfcs/pull/281">RFC #281</a>.</p></li>
<li><p>Use the <code>// @ts-ignore</code> to simply ignore the type-unsafety of the lookup. This approach is preferable when you don’t know if any of the keys might be missing. If, for example, either <code>some</code> or <code>nested</code> were <code>undefined</code> or <code>null</code>, the lookup example above in (1) would fail.</p>
<pre class="typescript"><code>import { get } from &#39;@ember/object&#39;;
// @ts-ignore -- deep lookup with possibly missing parents
const value = get(anObject, &#39;some.nested.key&#39;);</code></pre></li>
</ol>
</section>
</section>
<section id="actions" class="level3">
<h3>Actions</h3>
<p>What about actions? As usual, these just become class instance properties in the current scheme.</p>
<pre class="typescript"><code>  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&#39;aCollection&#39;);
      this.set(&#39;aCollection&#39;, current.concat(value));
    }
  };</code></pre>
<p>As with computed properties, we need the <code>this</code> type declaration to tell TypeScript that this method is going to be automatically bound to the class instance. Otherwise, TypeScript thinks the <code>this</code> here is the <code>actions</code> hash, rather than the <code>MyComponent</code> class.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Happily, that’s really all there is to it for actions: they’re quite straightforward other than needing the <code>this</code> type specification.</p>
</section>
<section id="types-in-.extend...-blocks" class="level3">
<h3>Types in <code>.extend({...})</code> blocks</h3>
<p>By and large, you can get away with using the same <code>this: MyComponent</code> trick when hacking around prototypal extension problems, or performance problems, by putting computed properties in a <code>.extend({...}</code> block. However, you <em>will</em> sometimes see a type error indicating that the class is referenced in its own definition expression. In that case, you may need to judiciously apply <code>any</code>, if you can’t make it work by using normal class properties.</p>
</section>
<section id="constructor-and-class-methods" class="level3">
<h3><code>constructor</code> and class methods</h3>
<p>ES6 class constructors and class methods both work as you’d expect, though as we’ll see you’ll need an extra bit of boilerplate for methods, at least for now.</p>
<pre class="typescript"><code>  constructor() {
    super();
    assert(&#39;`model` is required&#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample): void {
    if (!this.get(&#39;aCollection&#39;).includes(&#39;ahoy&#39;)) {
      this.set(&#39;aCollection&#39;, current.concat(&#39;ahoy&#39;));
    }
  }</code></pre>
<p>For the most part, you can just switch to using normal ES6 class constructors instead of the Ember <code>init</code> method. You can, if you so desire, also move existing <code>init</code> functions passed to a <code>.extends({ ...})</code> hash to class methods, and they’ll work once you change <code>this._super(...arguments)</code> to <code>super.init(...arguments)</code>. It’s worth pausing to understand the relationship between <code>init</code> and prototypal <code>init</code> and the <code>constructor</code>. An <code>init</code> in the <code>.extends()</code> hash runs first, then an <code>init</code> method on the class, then the normal <code>constructor</code>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Note that you do not need to (and cannot) annotate the <code>constructor</code> with <code>this: MyComponent</code>. Depending on the class you’re building, you may <em>occasionally</em> have type-checking problems that come up as a result of this. I’ve only ever seen that happen when using computed properties while defining a proxy,<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> but it does come up. In that case, you can fall back to using <code>init</code> as a method, and set <code>this: MyComponent</code> on <em>it</em>, and things will generally fall out as working correctly at that point. When it comes up, this seems to be just a limitation of what <code>this</code> is understood to be in a <code>constructor</code> given Ember’s rather more-complex-than-normal-classes view of what a given item being constructed is.</p>
<p>Other class methods do also need the <code>this</code> type specified if they touch computed properties. (Normal property access is fine without it.) That’s because the lookups for <code>ComputedProperty</code> instances (using <code>Ember.get</code> or <code>Ember.set</code>) need to know what <code>this</code> is where they should do the lookup, and the full <code>this</code> context isn’t inferred correctly at present. You can either write that on every invocation of <code>get</code>and <code>set</code>, like <code>(this as MyComponent).get(...)</code>, or you can do it once at the start of the method. Again, a bit boiler-platey, but it gets the job done and once you’re used to it it’s minimal hassle.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>One last note, which I didn’t include in the example: if you have a function (usually an action) passed into the component, you can define it most simply by just using <code>onSomeAction: Function;</code> in the class definition, right with other class arguments. However, it’s usually most helpful to define what the type should actually <em>be</em>, for your own sanity check if nothing else. As with e.g. <code>model</code> in this example, we don’t actually have a good way to type-check that what is passed is correct. We can, however, at least verify in the constructor that the caller passed in a function using <a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fdebug/methods/assert?anchor=assert"><code>assert</code></a>, just as with other arguments.</p>
</section>
</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<p>So that’s a wrap on components (and controllers, which behave much the same way).</p>
<p>In the next post, I’ll look at the elephant in the room: Ember Data (and closely related concern Ember CLI Mirage). While you <em>can</em> make Ember Data stuff largely work today, it’s still a ways from <em>Just Works™️</em>, sadly, but we’ll cover how to work around the missing pieces—we’ve gotten there in our own codebase, so you can, too!</p>
</section>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>As mentioned in <a href="https://v4.chriskrycho.com/2018/typing-your-ember-update-part-2.html">Part 2</a>, this problem doesn’t go away until we get decorators, unless you’re putting them on the prototype via <code>.extends()</code>—but see below for the problems with <em>that</em>. The short version is, we need decorators for this to actually be <em>nice</em>. Once we get decorators, we will be able to combine them with the work done for <a href="https://github.com/emberjs/rfcs/pull/281">RFC #281</a> and normal lookup will just work:</p>
<pre class="typescript"><code>@computed(&#39;model.firstName&#39;)
get fromModel() {
  return `My name is ${this.model.firstName};`;
}</code></pre>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></li>
<li id="fn2" role="doc-endnote"><p>I’ve used <code>Computed&lt;Person&gt;</code> and similar throughout here because it’s the most clear while still being reasonably concise. The actual type name in Ember’s own code is <code>ComputedProperty</code>, but <code>ComputedProperty&lt;Person&gt;</code> is <em>long</em>, and it wouldn’t have added any real clarity here. In my own codebase, we use <code>CP</code> (for “<strong>C</strong>omputed <strong>P</strong>roperty”) for the sake of brevity—so here that would just be <code>CP&lt;Person&gt;</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn3" role="doc-endnote"><p>In the future, this problem will hopefully be solved neatly by decorators:</p>
<pre class="typescript"><code>  @action
  addToCollection(value: string) {
    const current = this.get(&#39;aCollection&#39;);
    this.set(&#39;aCollection&#39;, current.concat(value));
  }</code></pre>
<p>For today, however, specifying a <code>this</code> type is where it’s at.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn4" role="doc-endnote"><p>You can see this for yourself in <a href="https://ember-twiddle.com/36844717dcc50d734139368edf2e87da">this Ember Twiddle</a>—just open your developer tools and note the sequence.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn5" role="doc-endnote"><p>Proxies, along with details of mixins, are a subject I’m leaving aside for Part 5, otherwise known as the “wow, this stuff is really weird to type” entry in the series.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn6" role="doc-endnote"><p>Not <em>no</em> hassle, though, and I look forward to a future where we can drop it, as Ember moves more and more toward modern JavaScript ways of solving these same problems!<a href="#fnref6" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
        </div>
    </div>
</article>


    <footer id="site-footer"><section id="connect">
    <h2>Connect</h2>
    <ul class="icons">
        <li><a href="mailto:chris at chriskrycho dot com"><i class="fa fa-fw fa-envelope"></i>Email</a></li>
        <li><a href="https://github.com/chriskrycho"><i class="fa fa-fw fa-github"></i>GitHub</a></li>
        <li><a href="https://twitter.com/chriskrycho"><i class="fa fa-fw fa-twitter"></i>Twitter</a></li>
        <li><a href="https://soundcloud.com/chriskrycho"><i class="fa fa-fw fa-soundcloud"></i>SoundCloud</a></li>
        <li><a href="http://www.linkedin.com/in/chriskrycho"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a></li>
        <li><a href="https://vimeo.com/chriskrycho"><i class="fa fa-fw fa-vimeo"></i>Vimeo</a></li>
        <li><a href="http://stackoverflow.com/users/564181/chris-krycho"><i class="fa fa-fw fa-stack-overflow"></i>Stack Overflow</a></li>
    </ul>
    <h3>Support Me</h3>
    <ul class='icons'>
        <li><a href="https://patreon.com/chriskrycho"><i class='fa fa-fw fa-money'></i>Patreon</a></li>
        <li><a href="https://cash.me/$chriskrycho"><i class='fa fa-fw fa-usd'></i>Cash.me</a></li>
    </ul>
</section>
<section id="subscribe">
    <h2>Subscribe</h2>
    <ul class="icons">
        <li class="section-title">
            <a onclick="window.open('http://eepurl.com/GzswP', 'subscribe', 'width=608,height=608')">
                   <i class="fa fa-fw fa-envelope"></i>Email
            </a>
        </li>
    </ul>
    <h3>Feeds</h3>
    <ul class="icons">
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feed.xml"><i class="fa fa-fw fa-rss"></i>Everything</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Art.xml"><i class="fa fa-fw fa-rss"></i>Art</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/blog.xml"><i class="fa fa-fw fa-rss"></i>blog</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Tech.xml"><i class="fa fa-fw fa-rss"></i>Tech</a>
        </li>
        <li class="section-title">
            <a href="http://v4.chriskrycho.com/feeds/Theology.xml"><i class="fa fa-fw fa-rss"></i>Theology</a>
        </li>
    </ul>
</section>
<section id="recent">
    <h2>Recent</h2>
    <ul>
        <li>Art: <a href="http://v4.chriskrycho.com/2019/time-does-not-heal.html">Time Does Not Heal</a></li>
        <li>Blog: <a href="http://v4.chriskrycho.com/2019/all-things-open-2019.html">All Things Open 2019!</a></li>
        <li>Tech: <a href="http://v4.chriskrycho.com/2019/announcing-rewrite.html">Announcing rewrite</a></li>
        <li>Theology: <a href="http://v4.chriskrycho.com/2019/heresies.html">Heresies</a></li>
    </ul>
</section></footer>

    <script type="text/javascript">
    var MTIProjectId='a34d2e31-99b5-469a-9b81-128fc0bd9745';
    </script>

<link rel="stylesheet" href="/assets/tomorrow.min.css">
<script src="/assets/js/highlight.pack.js"></script>
<script type="text/javascript">
// Get all the <pre><code> elements, and use the <pre> element to set the <code>
// element's class so hljs will use it rather than trying to figure it out.
var preEls = document.getElementsByTagName('pre');
for (var e in preEls) {
    var pre = preEls[e];
    if (pre.firstChild && pre.firstChild.tagName === 'CODE') {
        var code = pre.firstChild;
        code.className = pre.className;
    }
}

// Then run hljs.
hljs.initHighlightingOnLoad();
</script>

<script type="text/javascript" src="/assets/js/lib.js"></script>
</body>
</html>