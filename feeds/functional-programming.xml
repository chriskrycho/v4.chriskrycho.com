<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - functional programming</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sun, 31 Dec 2017 20:20:00 -0500</lastBuildDate><item><title>Exploring 4 Languages</title><link>http://www.chriskrycho.com/2017/exploring-4-languages.html</link><description>&lt;p&gt;Today, as I hit the first of the implementation chapters in &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt;, I started thinking about how I wanted to implement it. As I‚Äôve noted &lt;a href="https://twitter.com/chriskrycho/status/934170826718429184"&gt;elsewhere&lt;/a&gt; in the past, very little of the book is &lt;em&gt;truly&lt;/em&gt; specific to F&lt;sup&gt;‚ôØ&lt;/sup&gt;, though that‚Äôs the language Wlaschin uses in the book‚Äîand Wlaschin himself &lt;a href="https://twitter.com/ScottWlaschin/status/934177554331848705"&gt;agrees&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks! Yes, it‚Äôs true that you could easily use #ElmLang, #RustLang, #Scala, or especially #OCaml to work through the book. I use hardly any F# specific features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So‚Ä¶ I decided to try something a little bit bonkers. I‚Äôm going to implement these exercises in &lt;em&gt;four different languages&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fsharp.org"&gt;F&lt;sup&gt;‚ôØ&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reasonml.github.io"&gt;ReasonML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are all related: they‚Äôre descended from &lt;a href="http://smlnj.org/sml.html"&gt;Standard ML&lt;/a&gt;. ReasonML and F&lt;sup&gt;‚ôØ&lt;/sup&gt; are like siblings: Reason is merely a custom syntax for OCaml; F&lt;sup&gt;‚ôØ&lt;/sup&gt; is (originally) an implementation of OCaml on .NET (though the two languages have diverged since F&lt;sup&gt;‚ôØ&lt;/sup&gt; came into existence). Elm and Rust are cousins of each other and of Reason and F&lt;sup&gt;‚ôØ&lt;/sup&gt;, though they‚Äôre both drawing on other languages besides OCaml as well. I also have some familiarity with Rust, Elm, and F&lt;sup&gt;‚ôØ&lt;/sup&gt; already, and have read the docs for Reason a couple times. So this is a &lt;em&gt;bit&lt;/em&gt; less crazy than it might otherwise be.&lt;/p&gt;
&lt;p&gt;Why, though? Mostly because I think it‚Äôll be interesting to compare the implementations of the domain model from the book side by side. It‚Äôll look just a bit different in each language, and I expect to learn a bit more of the &lt;em&gt;feel&lt;/em&gt; of each language by doing this. (That side by side comparison is something I‚Äôve &lt;a href="http://www.chriskrycho.com/rust-and-swift.html" title="Series: Rust and Swift"&gt;done before&lt;/a&gt; and &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html" title="Part V: The value (and challenge) of learning languages in parallel."&gt;found very profitable&lt;/a&gt;.) I‚Äôll also turn it into blog posts, which hopefully will be interesting to others!&lt;/p&gt;
&lt;p&gt;More to come, and soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 31 Dec 2017 20:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-31:/2017/exploring-4-languages.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Types are Small</title><link>http://www.chriskrycho.com/2017/types-are-small.html</link><description>&lt;p&gt;I‚Äôve been reading through &lt;a href="https://fsharpforfunandprofit.com" title="F‚ôØ for Fun and Profit"&gt;Scott Wlaschin&lt;/a&gt;‚Äôs really excellent book &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt; and this quote (from his chapter introducing the idea of &lt;em&gt;types&lt;/em&gt; in &lt;em&gt;typed functional programming&lt;/em&gt;) crystallized something for me:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A type in functional programming is not the same as a class in object-oriented programming. It is much simpler. In fact, a type is just the name given to the set of possible values that can be used as inputs or outputs of a function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A lot of times when I‚Äôm trying to explain how I use types in a typed functional programming style, this is a serious point of confusion‚Äîboth for the Java or C‚ôØ OOP programmer and for the programmers coming from dynamic languages. When people think of ‚Äútypes‚Äù they tend to think of &lt;em&gt;classes and interfaces and methods, oh my!&lt;/em&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One is the big heavy class. The other is a nice little LEGO block. The difference is &lt;em&gt;huge&lt;/em&gt; in my day to day experience, but I‚Äôve never been able to express it so clearly as Wlaschin‚Äôs quote.&lt;/p&gt;
&lt;p&gt;I suspect that when I‚Äôm talking to most people coming from dynamically typed languages &lt;em&gt;or&lt;/em&gt; from the standard OOP languages, they hear ‚ÄúWrite three interfaces and six classes‚Äù when I say ‚Äúusing types to help me with my program.‚Äù But what I mean is ‚ÄúWrite three tiny little shapes, and then one more that shows how they snap together in a slightly bigger one.‚Äù Types aren‚Äôt big heavy things. They‚Äôre just the shapes I want to flow through my program, written down like documentation for later‚Ä¶ that gets checked for me to make sure it stays up to date, and lets me know if I missed something in my description of the shape of the data, or tried to do something I didn‚Äôt mean to before.&lt;/p&gt;
&lt;p&gt;You &lt;em&gt;can&lt;/em&gt; write a language like F‚ôØ or TypeScript or Elm like you would C‚ôØ, but it‚Äôs generally not going to be an especially &lt;em&gt;happy&lt;/em&gt; experience (and it‚Äôll be less happy the more ‚Äúpurely functional,‚Äù &lt;em&gt;a la&lt;/em&gt; Elm, you go). But you don‚Äôt have to! Types are just tiny little descriptions of the shapes you plan to deal with in a particular spot‚Äîmore concise and more dependable than writing a JSDoc or something like that.&lt;/p&gt;
&lt;p&gt;Types are small. You can build big things with them, but &lt;em&gt;types are small&lt;/em&gt;.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;In fact, nearly every ‚ÄúI‚Äôm just not into types‚Äù or even ‚ÄúI think types are worse for most things‚Äù talks I‚Äôve seen‚Äîincluding &lt;a href="https://www.youtube.com/watch?v=2V1FtfBDsLU"&gt;this recent and popular one by Rich Hickey&lt;/a&gt;‚Äîtend to conflate &lt;em&gt;all&lt;/em&gt; type systems together. But the experience of writing TypeScript is &lt;em&gt;very&lt;/em&gt; different from the experience of writing C‚ôØ. (You‚Äôll note that in that talk, for example, Hickey freely jumps back and forth between Java-style types and Haskell-style types when it suits his purposes, and he entirely skips past the structural type systems currently having something of a heyday.) In many cases, I &lt;em&gt;suspect&lt;/em&gt; this is simply a lack of deep experience with the whole variety of type systems out there (though I‚Äôd not attribute that to any specific individual).&lt;a href="#fnref1" class="footnote-back"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 29 Dec 2017 14:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-29:/2017/types-are-small.html</guid><category>functional programming</category><category>software development</category></item><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I‚Äôm pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I‚Äôve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value‚Äîwhich it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure‚Äîwhich it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself ‚Äì it‚Äôs not hard! ‚Äì¬†but it‚Äôs much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects‚Äîwhich we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you‚Äôre familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them‚Äîits main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren‚Äôt already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default‚Äîit relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don‚Äôt have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we‚Äôd write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn‚Äôt a big deal right here‚Ä¶ but‚Äîand this &lt;em&gt;is&lt;/em&gt; a big deal‚Äîwe have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. üò¨&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;‚Äîas in, ‚ÄúWhat‚Äôs in this field? Just a string‚Äù or ‚ÄúJust the string ‚Äòhello‚Äô‚Äù. If there‚Äôs nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you‚Äôll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it‚Äôs a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it‚Äôs present and do nothing if it isn‚Äôt, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here‚Äôs that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We‚Äôre using TypeScript, so we will get a compiler error if we don‚Äôt handle any of these cases right‚Äîor if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we‚Äôve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That‚Äôs true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you‚Äôre &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn‚Äôt a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat ‚Äúno value‚Äù distinctly from ‚Äúthere‚Äôs a value present, and it‚Äôs an empty string‚Äù? &lt;em&gt;That‚Äôs&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g.¬†Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs incredibly repetitive ‚Äì the very opposite of ‚ÄúDon‚Äôt Repeat Yourself‚Äù. We wouldn‚Äôt do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it‚Äôs not usually the &lt;em&gt;point&lt;/em&gt; of most functions ‚Äì things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we‚Äôre not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can‚Äôt know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it‚Äôs a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it‚Äôs very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there‚Äôs no way for the caller to know that the function will throw. Perhaps you‚Äôre very disciplined and write good docstrings for every function ‚Äì &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone‚Äôs editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data ‚Äì¬†and then you‚Äôre chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you‚Äôre going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can‚Äôt help you here! They don‚Äôt have type signatures to say ‚ÄúThis throws an exception!‚Äù (TypeScript‚Äôs &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
value.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it‚Äôs &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that‚Äôs right away. Maybe we don‚Äôt need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you‚Äôre using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think ‚Äì if there‚Äôs stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it‚Äôs just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category></item><item><title>‚ÄúCollection-Last Auto-Curried Functions‚Äù</title><link>http://www.chriskrycho.com/2017/collection-last-auto-curried-functions.html</link><description>&lt;p&gt;I‚Äôve been using &lt;a href="https://lodash.com"&gt;lodash&lt;/a&gt; for a while at work, and I love having it in our toolbox. But, as I increasingly embrace &lt;em&gt;composition of smaller functions&lt;/em&gt; as a helpful approach to building up the final version of an overall transformation of some piece of data, I‚Äôve increasingly wanted to be using &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt; instead‚Äîthose ‚Äúauto-curried‚Ä¶ data-last methods‚Äù are &lt;em&gt;nice&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I could belabor the difference with words, but a code sample will do better. Here‚Äôs how I would write the same basic transformation in both Lodash and lodash-fp.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// Lodash
const breakfasts = [&amp;#39;pancakes&amp;#39;, &amp;#39;waffles&amp;#39;, &amp;#39;french toast&amp;#39;]

const uniqueLetters = _.flow([
  bs =&amp;gt; _.map(bs, words),
  _.flatten,
  bs =&amp;gt; _.map(bs, b =&amp;gt; split(b, &amp;#39;&amp;#39;)),
  _.flatten,
  _.uniq,
  ls =&amp;gt; _.sortBy(ls, id),
])

console.log(uniqueLetters(breakfasts))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That gets the job done, but wouldn‚Äôt it be nice if we didn‚Äôt have to have all those anonymous functions (lambdas) throughout?&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// lodash-fp
const uniqueLettersFp = _.flow([
  _.map(words),
  _.flatten,
  _.map(split(&amp;#39;&amp;#39;)),
  _.flatten,
  _.uniq,
  _.sortBy(id),
])

const breakfasts = [&amp;#39;pancakes&amp;#39;, &amp;#39;waffles&amp;#39;, &amp;#39;french toast&amp;#39;]

console.log(uniqueLettersFp(breakfasts))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suddenly the intent is much clearer with the noise introduced by the lambdas gone. You get this because the lodash-fp functions are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;auto-curried:&lt;/strong&gt; that is, even though &lt;code&gt;_.split&lt;/code&gt; takes the splitter and then a string, you can just write &lt;code&gt;_.split('')&lt;/code&gt; and get back a function which takes a string as an argument.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data-last:&lt;/strong&gt; because &lt;code&gt;_.split&lt;/code&gt; takes the string to split &lt;em&gt;last&lt;/em&gt;, it can be passed into an auto-curried function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You need &lt;em&gt;both&lt;/em&gt; to get that nice clean call to &lt;code&gt;_.flow&lt;/code&gt;. But once you have both, it‚Äôs really, really hard ever to go back, because it‚Äôs so much nicer for building pipelines of functions.&lt;/p&gt;
&lt;p&gt;‚Ä¶I need to see if I can help &lt;a href="https://github.com/mike-north/ember-lodash/issues/21"&gt;do the work&lt;/a&gt; to make lodash-fp available in Ember.js.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 24 Jun 2017 17:35:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-06-24:/2017/collection-last-auto-curried-functions.html</guid><category>javascript</category><category>functional programming</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we‚Äôre both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I‚Äôll be reusing some of this material as the basis of an internal tech talk I‚Äôm giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs not tied to JS directly, which means it‚Äôs free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That‚Äôs the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it‚Äôs‚Ä¶ still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm‚Äôs type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript‚Äôs is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; ‚Äì not mostly sure, 100% sure ‚Äì that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say ‚Äúby design,‚Äù I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of ‚Äúsoundness holes‚Äù in the type system‚Äîthere‚Äôs still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS‚Ä¶ but not none. (That‚Äôs even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It‚Äôs just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm‚Äôs language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean‚Äî&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that‚Äôs no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I‚Äôd summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title>Better Off Using Exceptions?</title><link>http://www.chriskrycho.com/2017/better-off-using-exceptions.html</link><description>&lt;p&gt;I saw this post on error-handling in F&lt;sup&gt;‚ôØ&lt;/sup&gt;, &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You‚Äôre better off using Exceptions"&gt;‚ÄúYou‚Äôre better off using Exceptions‚Äù&lt;/a&gt; making the rounds on Twitter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exception handling is an error management paradigm that has often been met with criticism. Such criticisms typically revolve around scoping considerations, exceptions-as-control-flow abuse or even the assertion that exceptions are really just a type safe version of goto. To an extent, these seem like valid concerns but it is not within the scope of this article to address those per se.&lt;/p&gt;
&lt;p&gt;Such concerns resonate particularly well within FP communities, often taken to the extreme: we should reject exceptions Show more‚Ä¶&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And I get the argument, and in the specific context of F&lt;sup&gt;‚ôØ&lt;/sup&gt;‚Äîespecially given how much C&lt;sup&gt;‚ôØ&lt;/sup&gt;-interoperating and therefore exception-throwing-code-interoperating there is there‚Äîit‚Äôs reasonable.&lt;/p&gt;
&lt;p&gt;But it still makes me sad. (To be clear: exceptions were and are a big win over what you get in languages like C. I‚Äôll take them any day over &lt;code&gt;goto&lt;/code&gt; or &lt;code&gt;segfault&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;You need to embrace exceptions in F&lt;sup&gt;‚ôØ&lt;/sup&gt; &lt;em&gt;because F&lt;sup&gt;‚ôØ&lt;/sup&gt; has exceptions&lt;/em&gt; and because &lt;em&gt;many of its libraries rely on exceptions&lt;/em&gt;. But my experience with Rust and other non-exception-using languages is that you &lt;em&gt;don‚Äôt&lt;/em&gt; need exceptions in the general case.&lt;/p&gt;
&lt;p&gt;The questions are: whether your language has good support for things like flat-mapping, and whether you‚Äôre willing to commit to letting the compiler help you with these problems.&lt;/p&gt;
&lt;p&gt;To be sure: there‚Äôs more work involved up front to deal with that. But that‚Äôs a tradeoff I‚Äôm &lt;em&gt;always&lt;/em&gt; willing to make. I‚Äôd rather have the compiler tell me if I‚Äôm failing to account for something than learn because I saw a runtime error report come up in &lt;a href="https://raygun.com"&gt;Raygun&lt;/a&gt;, especially because that tends to mean an error that affects the user in some way.&lt;/p&gt;
&lt;p&gt;Rust‚Äôs model gives you something like exceptions for truly unrecoverable errors, ‚Äúpanics.‚Äù A panic gives you all the context you‚Äôd get from an exception (one of the virtues of exceptions highlighted in that post), but you can only ‚Äúcatch‚Äù it at thread boundaries, and it otherwise just kills the program. Because it‚Äôs catastrophic, you only use it where you don‚Äôt have any way to recover in your immediate context. But where you can recover in your immediate context‚Ä¶ using something like a highly descriptive enum (just as suggested at the end of &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You‚Äôre better off using Exceptions"&gt;that original post&lt;/a&gt;!) is a better option.&lt;/p&gt;
&lt;p&gt;It‚Äôs well-understood in my circles that you shouldn‚Äôt use exceptions for things you can recover from; you should use them for things you &lt;em&gt;can‚Äôt&lt;/em&gt; recover from. But in most languages which lean heavily on exceptions, you inevitably start using them for control flow. I say: if you can recover from an error‚Ä¶ just recover from it! Account for recoverable errors as possible conditions in your program and carry on! If you can‚Äôt recover‚Ä¶ don‚Äôt. Die and let some other part of your system kick things back off.&lt;/p&gt;
&lt;p&gt;In summary: yes, if you‚Äôre in F&lt;sup&gt;‚ôØ&lt;/sup&gt;, use exceptions. It &lt;em&gt;is&lt;/em&gt; the right thing to do in many cases (and you don‚Äôt have a choice in many others). But I‚Äôm hopeful for a future where we handle recoverable errors locally, and &lt;a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html"&gt;act like Erlang or Elixir otherwise&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 20 Feb 2017 12:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-02-20:/2017/better-off-using-exceptions.html</guid><category>fsharp</category><category>software development</category><category>rust</category><category>functional programming</category></item><item><title>The Itch</title><link>http://www.chriskrycho.com/2016/the-itch.html</link><description>&lt;p&gt;It took me until just a few weeks ago to put my finger on why typed functional programming, as a style and approach, has appealed to me so much as I started picking it up over the last year. For all its novelty, typed FP feels‚Äîover and over again‚Äî&lt;em&gt;familiar&lt;/em&gt;. Strange to say, but it‚Äôs true.&lt;/p&gt;
&lt;p&gt;This came home to me again when reading a &lt;a href="https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6#.e887yz63p"&gt;short post on functors&lt;/a&gt;‚Äîi.e., &lt;em&gt;mappable&lt;/em&gt; types. I‚Äôve written a lot of JavaScript in the last few years, and it has been a source of constant frustration to me that &lt;code&gt;Array&lt;/code&gt; implements the &lt;code&gt;map&lt;/code&gt; method, but &lt;code&gt;Object&lt;/code&gt; does not. Countless times, I have wanted to take an object shaped like &lt;code&gt;{ count: &amp;lt;number&amp;gt; }&lt;/code&gt; and transform that &lt;code&gt;count&lt;/code&gt;. I‚Äôm not alone in that. There‚Äôs a reason that libraries like &lt;a href="http://underscorejs.org"&gt;Underscore&lt;/a&gt;, &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;, and &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; all supply utilities to allow you to map over objects. There are also good reasons why it &lt;em&gt;isn‚Äôt&lt;/em&gt; implemented for on &lt;code&gt;Object.prototype&lt;/code&gt;: the reality is that coming up with a predictable &lt;em&gt;and&lt;/em&gt; useful API for &lt;em&gt;all&lt;/em&gt; &lt;code&gt;Object&lt;/code&gt; instances is difficult at best: Objects are used for everything from dictionaries to records and strange combinations of the two. But still: there‚Äôs something there.&lt;/p&gt;
&lt;p&gt;And reading this post on functors, it struck me what that ‚Äúsomething‚Äù is: object types are, in principle, functors. Maybe it doesn‚Äôt make sense to have a single &lt;code&gt;map&lt;/code&gt; implementation for every &lt;code&gt;Object&lt;/code&gt; instance out there. But they‚Äôre perfectly mappable. I didn‚Äôt have a word for this before tonight, but now I do. Over and over again, this is my experience with functional programming.&lt;/p&gt;
&lt;p&gt;There‚Äôs this familiar feeling of frustration I‚Äôm slowly coming to recognize‚Äîa mental sensation which is a little like the intellectual equivalent of an itch in a spot you can‚Äôt quite reach. You‚Äôre reaching for an abstraction to express an idea, but you don‚Äôt even know that there &lt;em&gt;is&lt;/em&gt; an abstraction for it. You want to map over objects, and you don‚Äôt know why that seems so reasonable, but it does. And then someone explains functors to you. It scratches the itch.&lt;/p&gt;
&lt;p&gt;Another example. Since I started programming eight and a half years ago, I‚Äôve worked seriously with Fortran, C, C++ PHP, Python, and JavaScript. In each of those languages (and especially in the C-descended languages), I have found myself reaching for enums or things like them as a way of trying to represent types and states in my system in a more comprehensive way. I figured out that you should &lt;a href="http://wiki.c2.com/?UseEnumsNotBooleans"&gt;use enums not booleans&lt;/a&gt; a long time before I found the advice on the internet. I was encoding error types as enum values instead of just using &lt;code&gt;int&lt;/code&gt;s almost as soon as I started, because it was obvious to me that &lt;code&gt;ErrorCode someFunction() { ... }&lt;/code&gt; was far more meaningful than &lt;code&gt;int someFunction() { ... }&lt;/code&gt; (even if the context of C meant that the latter often implied the former, and even if it was trivial to coerce one to the other).&lt;/p&gt;
&lt;p&gt;Then I read &lt;a href="https://gumroad.com/l/maybe-haskell/"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;, a book I‚Äôve mentioned often on this blog because it was so revelatory for me. This is what I had been reaching for all those years‚Äîand then some. Handing data around with the constraints? Yes, please! I had played with unions, enums, structs with enums inside them, anything to try to get some type-level clarity and guarantees about what my code was doing. Haskell showed me the way; and since then Rust and Elm and F# have reinforced it many times over. &lt;a href="https://guide.elm-lang.org/types/union_types.html"&gt;Tagged unions&lt;/a&gt; are a joy. They let me say what I mean‚Äîfinally.&lt;/p&gt;
&lt;p&gt;I can still feel that itch. It‚Äôs shifted a little, but it‚Äôs still there: reaching for higher abstractions to let me tell the machine more clearly what I intend. Half a dozen times this year, I‚Äôve realized: &lt;em&gt;Here&lt;/em&gt; is where dependent types would be useful. They‚Äôre far beyond me, but close enough now I can see. I‚Äôm sure a year from now, I‚Äôll have find some tools to scratch &lt;em&gt;these&lt;/em&gt; itches, only to discover a few more.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Dec 2016 21:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-19:/2016/the-itch.html</guid><category>software development</category><category>functional programming</category><category>Rust</category><category>JavaScript</category></item><item><title>What is Functional Programming?</title><link>http://www.chriskrycho.com/2016/what-is-functional-programming.html</link><description>&lt;p&gt;&lt;i class='editorial'&gt;The following is a script I wrote for a tech talk I gave on functional programming. The recording isn‚Äôt (and won‚Äôt be) publicly available; but a script is often easier to reference anyway!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; updated with corrected performance characterstics.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Hello, everyone. Today, we are going to talk about functional programming‚Äîasking what it is, and why we should care.&lt;/p&gt;
&lt;section id="clearing-the-table-functional-programmings-reputation" class="level2"&gt;
&lt;h2&gt;Clearing the Table: Functional Programming‚Äôs Reputation&lt;/h2&gt;
&lt;p&gt;Functional programming has something of a reputation: on the one hand, as incredible difficult, dense, full of mathematical jargon, applicable only to certain fields like machine learning or massive data analysis; on the other hand, as a kind of panacea that solves all of your problems. The reality, I think, is a little bit of both.&lt;/p&gt;
&lt;p&gt;The world of functional programming &lt;em&gt;does&lt;/em&gt; include a lot of jargon from the math world, and there are good reasons for that, but there is also a lot we could do to make it more approachable to people who don‚Äôt have a background in, say category. Category theory is useful, of course, and I think there are times when we might want to be able to draw on it. But gladly, functional programming doesn‚Äôt require you to know what an &lt;em&gt;applicative functor&lt;/em&gt; is to be able to use it. (And, gladly, there‚Äôs a lot of increasingly-solid teaching material out there about functional programming which &lt;em&gt;doesn‚Äôt&lt;/em&gt; lean on math concepts.)&lt;/p&gt;
&lt;p&gt;On the other side, functional programming does give us some real and serious benefits, and that‚Äôs what I‚Äôm going to spend the first third or so of this talk looking at. But of course, it‚Äôs still just a tool, and even though it is a very helpful and very powerful tool, it can‚Äôt keep us from writing bugs. Still, every tool we can add to our belt for writing correct software is a win.&lt;/p&gt;
&lt;p&gt;One more prefatory note before we get into the meat of this talk: unfamiliar terminology is not specific to functional programming. So, yes, when you see this list, it might seem a little out there:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functor&lt;/li&gt;
&lt;li&gt;Applicative&lt;/li&gt;
&lt;li&gt;Monoid&lt;/li&gt;
&lt;li&gt;Monad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And in truth, a number of those could have better names. &lt;em&gt;But&lt;/em&gt; we have plenty of terminology we throw around in the world of imperative, object-oriented programming. To pick just one, obvious and easy example‚Äîwhat are the &lt;abbr&gt;SOLID&lt;/abbr&gt; principles?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single reponsibility&lt;/li&gt;
&lt;li&gt;Open/closed&lt;/li&gt;
&lt;li&gt;Liskov substitution&lt;/li&gt;
&lt;li&gt;Interface segregation&lt;/li&gt;
&lt;li&gt;Dependency inversion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may not remember what it felt like the first time you encountered &lt;abbr&gt;SOLID&lt;/abbr&gt;, but suffice it to say: ‚ÄúLiskov substitution principle‚Äù isn‚Äôt any more intuitive or obvious than ‚ÄúMonad‚Äù. You‚Äôre just familiar with one of them. The same is true of ‚Äúapplicative‚Äù and ‚ÄúVisitor pattern‚Äù. And so on. Granted, again: it would be nice for some of these things to have easier names, a &lt;em&gt;big&lt;/em&gt; part of the pain here is just unfamiliarity.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, what &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming" class="level2"&gt;
&lt;h2&gt;What is functional programming?&lt;/h2&gt;
&lt;p&gt;Functional programming is a style of programming that uses &lt;em&gt;pure functions&lt;/em&gt; and &lt;em&gt;immutable data&lt;/em&gt; for as many things as possible, and builds programs primarily out of &lt;em&gt;functions&lt;/em&gt; rather than other abstractions. I‚Äôll define all of those terms in a moment, but first‚Ä¶&lt;/p&gt;
&lt;section id="why-do-we-care" class="level3"&gt;
&lt;h3&gt;Why do we care?&lt;/h3&gt;
&lt;p&gt;We care, frankly, because &lt;em&gt;we‚Äôre not that smart&lt;/em&gt;. Let‚Äôs think about some of the kinds of things we‚Äôre doing with, say, restaurant software: clients, with locations, building baskets, composed of products with options and modifiers, which have a set of rules for what combinations are allowed both of products and of their elements as making up a basket, which turn into orders, which have associated payment schemes (sometimes a lot of them), which generate data to send to a point-of-sale as well as summaries for the customer who ordered it, and so on. There are a &lt;em&gt;lot&lt;/em&gt; of moving pieces there. I‚Äôm sure a missed some non-trivial pieces, too. And if all of that is &lt;em&gt;stateful&lt;/em&gt;, that‚Äôs a lot of state to hold in your head.&lt;/p&gt;
&lt;p&gt;Let me be a bit provocative for a moment. Imagine you were reading a JavaScript module and it looked like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var foo = 12;
var bar = &amp;#39;blah&amp;#39;;
var quux = { waffles: &amp;#39;always&amp;#39; };

export function doSomething() {
  foo = 42;
}

export function getSomething() {
  bar = quux;
  quux.waffles = &amp;#39;never&amp;#39;;
  return bar;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everyone watching would presumably say, ‚ÄúNo that‚Äôs bad, don‚Äôt do that!‚Äù Why? Because there is &lt;em&gt;global state&lt;/em&gt; being changed by those functions, and there‚Äôs nothing about the functions which tells you what‚Äôs going on. Global variables are bad. Bad bad bad. We all know this. Why is it bad? Because you have no idea when you call &lt;code&gt;doSomething()&lt;/code&gt; or &lt;code&gt;getSomething()&lt;/code&gt; what kinds of side effects it might have. And if &lt;code&gt;doSomething()&lt;/code&gt; and &lt;code&gt;getSomething()&lt;/code&gt; affect the same data, then the order you call them in matters.&lt;/p&gt;
&lt;p&gt;In a previous job, I spent literally months chasing a bunch of bugs in a C codebase where all of the state was global. &lt;em&gt;We don‚Äôt do this anymore.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;But really, what‚Äôs different about this?&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class AThing {
  constructor() {
    this.foo = 12;
    this.bar = &amp;#39;blah&amp;#39;;
    this.quux = { waffles: &amp;#39;always&amp;#39; };
  }

  doSomething() {
    this.foo = 42;
  }

  getSomething() {
    this.bar = this.quux;
    this.quux.waffles = &amp;#39;never&amp;#39;;
    return this.bar;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have some ‚Äúinternal‚Äù data, just like we had in the module up above. And we have some public methods which change that state. In terms of these internals, it‚Äôs the same. There are differences in terms of having &lt;em&gt;instances&lt;/em&gt; and things like that, but in terms of understanding the behavior of the system‚Äîunderstanding the state involved‚Äîit‚Äôs the same. It‚Äôs global, mutable state. Now it‚Äôs not global like attaching something to the &lt;code&gt;window&lt;/code&gt; object in JavaScript, and that‚Äôs good, but still: at the module or class level, it‚Äôs just global mutable state, with no guarantees about how anything works. And this is normal‚Äîendemic, even‚Äîin object-oriented code. We encapsulate our state, but we have &lt;em&gt;tons&lt;/em&gt; of state, it‚Äôs all mutable, and as far as any given class method call is concerned, it‚Äôs all global to that class.&lt;/p&gt;
&lt;p&gt;You have no idea, when you call a given object method, what it might do. The fact that you call it with an &lt;code&gt;Int&lt;/code&gt; and get out a &lt;code&gt;String&lt;/code&gt; tells you almost nothing. For all you know, it‚Äôs triggering a &lt;abbr&gt;JSON-RPC&lt;/abbr&gt; call using the int as the &lt;abbr&gt;ID&lt;/abbr&gt; for the endpoint, which in turn triggers an operation, responds with another &lt;abbr&gt;ID&lt;/abbr&gt;, which you then use to query a database, and load a string from there, which you then set on some other member of the object instance, and then return. Should you write a method that does that? Probably not. But you can; nothing stops you.&lt;/p&gt;
&lt;p&gt;When you call a method, you have no idea what it will do. JavaScript, TypeScript, C&lt;sup&gt;‚ôØ&lt;/sup&gt;, it doesn‚Äôt matter. You have literally no idea. And that makes things &lt;em&gt;hard&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It often makes fixing bugs hard, because it means you have to figure out which particular &lt;em&gt;state&lt;/em&gt; caused the issue, and find a way to reproduce that state. Which usually means calling methods in a particular order.&lt;/li&gt;
&lt;li&gt;It makes testing hard. Again, it often entails calling methods in a particular order. It also means you often need mocks for all those outside-world things you‚Äôre trying to do.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Functional programming is an out. An escape hatch. An acknowledgement, a recognition, that holding all of this in our heads is too much for us. No one is that smart. And our software, even at its best, is hard to hold in our heads, hard to make sure that our changes don‚Äôt break something seemingly unrelated, hard to see how the pieces fit together‚Äîhard, in a phrase you‚Äôll often hear from functional programming fans, hard to reason about.&lt;/p&gt;
&lt;p&gt;So, how do we solve these problems? With functional programming!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming-1" class="level3"&gt;
&lt;h3&gt;What &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/h3&gt;
&lt;p&gt;Functional programming is basically combining four bigs ideas:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;First class functions&lt;/li&gt;
&lt;li&gt;Higher-order functions&lt;/li&gt;
&lt;li&gt;Pure functions&lt;/li&gt;
&lt;li&gt;Immutable data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The combination of these things leads us to a &lt;em&gt;very&lt;/em&gt; different style of programming than traditional &lt;abbr&gt;OOP&lt;/abbr&gt;. Let‚Äôs define them.&lt;/p&gt;
&lt;section id="first-class-functions-and-higher-order-functions" class="level4"&gt;
&lt;h4&gt;First class functions and higher-order functions&lt;/h4&gt;
&lt;p&gt;We‚Äôll start by looking at the things that are probably most familiar to you if you‚Äôre a JavaScript developer (even if you haven‚Äôt necessarily heard the names): first-class functions and higher-order functions.&lt;/p&gt;
&lt;p&gt;When we talk about &lt;em&gt;first class functions,&lt;/em&gt; we mean that functions are just data‚Äîthey‚Äôre first-class items in the language just like any other type. As such, a function is just another thing you can hand around as an argument to other functions. There‚Äôs no distinction between a function and a number or a string or some complex data structure. This is essential because, when you combine it with higher-order functions, it allows for incredible &lt;em&gt;simplicity&lt;/em&gt; and incredible &lt;em&gt;reusability&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Higher-order functions, in turn, are functions which take other functions as parameters or return them as their values. We‚Äôll see this in detail in a worked example in a few, but for right now, let‚Äôs just use a really simple example that will be familiar to anyone who‚Äôs done much JavaScript: using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we have a collection like an array and we want to transform every piece of data in it, we could of course do it with a for loop, and with iterable types we could use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;&lt;code&gt;for ... of&lt;/code&gt;&lt;/a&gt;. But with &lt;code&gt;map&lt;/code&gt;, we can just leave the implementation details of &lt;em&gt;how&lt;/em&gt; the items in the array are iterated through, and instead worry about what we want to change. We can do that because &lt;code&gt;map&lt;/code&gt; takes functions as arguments.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(value =&amp;gt; value * 2);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We did it there with a function explicitly, but we could just as easily extract the function like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const double = value =&amp;gt; value * 2;
const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(double);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is possible because &lt;em&gt;functions are just data&lt;/em&gt;‚Äîthey‚Äôre first-class members of the language‚Äîand therefore &lt;em&gt;functions can be arguments or return values&lt;/em&gt;‚Äîthe language supports higher-order functions.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="pure-functions" class="level4"&gt;
&lt;h4&gt;Pure functions&lt;/h4&gt;
&lt;p&gt;What about &lt;em&gt;pure functions&lt;/em&gt;? Pure functions are functions with &lt;em&gt;no effects&lt;/em&gt;. The input directly translates to the output, every time. The examples we looked at just a moment ago with &lt;code&gt;map&lt;/code&gt; are all pure functions (and it‚Äôs a really weird antipattern to use effectful functions with &lt;code&gt;map&lt;/code&gt;! Don‚Äôt do that! Use &lt;code&gt;forEach&lt;/code&gt; if you must have an effect). Here are a few more super simple examples:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const toString = (number) =&amp;gt; `The value is ${number}`;
const toLength = (list) =&amp;gt; list.length;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are some examples of straightforward functions which are &lt;em&gt;not&lt;/em&gt; pure:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const logDataFromEndpoint = (endpoint) =&amp;gt; {
  fetch(endpoint).then(response =&amp;gt; {
    console.log(response);
  });
};

let foo = 42;
const setFoo = (newValue) =&amp;gt; {
  foo = newValue;
};

const getFoo = () =&amp;gt; foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So a pure function is one whose output is &lt;em&gt;solely&lt;/em&gt; determined by its input That means no talking to a database, no making &lt;abbr&gt;API&lt;/abbr&gt; calls, no reading from or writing to disk.&lt;/p&gt;
&lt;p&gt;And of course, you can‚Äôt do anything meaningful with &lt;em&gt;just&lt;/em&gt; pure functions. We need user input, and we need to put the results of our computation somewhere. So the goal isn‚Äôt to write &lt;em&gt;only&lt;/em&gt; pure functions. It‚Äôs to write &lt;em&gt;mostly&lt;/em&gt; pure functions and to &lt;em&gt;isolate&lt;/em&gt; all impure functions.&lt;/p&gt;
&lt;p&gt;What this gets us is two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;A much smaller list of things to worry about when we‚Äôre looking at a given function.&lt;/li&gt;
&lt;li&gt;The ability to &lt;em&gt;compose&lt;/em&gt; functions together more easily.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have fewer things to keep in our heads when we look at any given pure function, because we don‚Äôt have to worry at all about whether something it touches has been changed by another function or not. We have inputs. We transform them into outputs. That‚Äôs it. Compare these two things in practice.&lt;/p&gt;
&lt;p&gt;Here‚Äôs a traditional &lt;abbr&gt;OOP&lt;/abbr&gt; approach:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class Order {
  constructor() {
    this.subTotal = 0.0;
    this.taxRate = 0.01;
  }

  getTotal() {
    return this.subTotal * (1 + this.taxRate);
  }
}

const order = new Order();
order.subTotal = 42.00;

const total = order.getTotal();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the total is always dependent on what has happened in the object. If we write &lt;code&gt;order.subTotal = 43&lt;/code&gt;, &lt;code&gt;order.total&lt;/code&gt; will change. So if we want to test how &lt;code&gt;total&lt;/code&gt; behaves, or if there‚Äôs a bug in it, we need to make sure we‚Äôve made all the appropriate transformations to the object ahead of time. That‚Äôs no big deal here; the &lt;code&gt;total&lt;/code&gt; getter is incredibly simple (and in fact, we‚Äôd normally just write it with a property getter). But still, we have to construct an order and make sure all the relevant properties are set to get the right value out of &lt;code&gt;getTotal()&lt;/code&gt;. Things outside the method call itself affect what we get back. We have no way to test &lt;code&gt;getTotal()&lt;/code&gt; by itself, and no way to debug it if there‚Äôs a bug without first doing some object setup.&lt;/p&gt;
&lt;p&gt;Now, here‚Äôs a functional approach.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const order = {
  subTotal: 42.0,
  taxRate: 0.01
}

const getTotal = (subTotal, taxRate) =&amp;gt; subTotal * (1 + taxRate);
const total = getTotal(order.subTotal, order.taxRate);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the object is &lt;em&gt;just data&lt;/em&gt;. It‚Äôs a &lt;em&gt;record&lt;/em&gt;. And the function just takes a couple of arguments. If there needed to be a more complicated transformation internally, we could do that just as easily. Note that it also decouples the structure of the data from the actual computation (though we could pass in a record as well if we had a good reason to).&lt;/p&gt;
&lt;p&gt;This makes it easily testable, for free. Want to make sure different tax rates get the correct output? Just‚Ä¶ pass in a different tax rate. You don‚Äôt have to do any complicated work setting up an object instance first (which is especially important for more complex data types). It also makes it easier to chase down any bugs: the only thing you have to care about is that simple function body. There‚Äôs no other state to think about, because there‚Äôs no state at all here from the perspective of the function: just inputs and outputs.&lt;/p&gt;
&lt;p&gt;This has one other &lt;em&gt;really&lt;/em&gt; important consequence, which goes by the name &lt;strong&gt;referential transparency&lt;/strong&gt;. All that means is that anywhere you see a pure function, you can always substitute the value it produces, or vice versa. This is quite unlike the &lt;code&gt;Order::getTotal()&lt;/code&gt; method, where (a) it‚Äôs attached to an object instance and (b) it‚Äôs dependent on other things about that object. You can‚Äôt just substitute it in, or freely move it around, when you‚Äôre doing a refactor. &lt;em&gt;Maybe&lt;/em&gt; you can, but you‚Äôd better hope that all the other state is shuffled around with it correctly. Whereas, with the standalone &lt;code&gt;getTotal()&lt;/code&gt; function, all you need is its arguments, and you‚Äôll always get the same thing back.&lt;/p&gt;
&lt;p&gt;This is just like math: if you say, &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;‚ÄÑ=‚ÄÑ5&lt;/span&gt; when solving an algebraic equation, you can put &lt;span class="math inline"&gt;5&lt;/span&gt; &lt;em&gt;anywhere you see &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;; or, if it‚Äôs useful for factoring the equation or something, you can just as easily put &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; anywhere you see &lt;span class="math inline"&gt;5&lt;/span&gt;. And in math, that‚Äôs true for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; as well. When we use pure functions, it‚Äôs true for programming, too! That makes refactoring much easier.&lt;/p&gt;
&lt;p&gt;As we‚Äôll see in the example I walk through in a minute, it also lets us &lt;em&gt;compose&lt;/em&gt; functions together far more easily. If all we have are inputs and outputs, then I can take the output from one function and use it as the input to the next.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="immutable-data" class="level4"&gt;
&lt;h4&gt;Immutable data&lt;/h4&gt;
&lt;p&gt;Complementing the use of mostly pure functions is to use &lt;em&gt;immutable data&lt;/em&gt;. Instead of having objects which we mutate, we create copies of the data as we transform it.&lt;/p&gt;
&lt;p&gt;You‚Äôre probably wondering how in the world this can work (and also how you avoid it being incredibly computationally expensive). For the most part, we can rely on two things: smart compilers and runtimes, and the fact that we often don‚Äôt need to reuse the &lt;em&gt;exact&lt;/em&gt; same data because we‚Äôre transforming it. However, as we‚Äôll see below, in languages which don‚Äôt have native support for immutability, it can impose a performance penalty. Gladly, there are ways to work around this!&lt;/p&gt;
&lt;hr /&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="a-worked-example" class="level2"&gt;
&lt;h2&gt;A Worked Example&lt;/h2&gt;
&lt;p&gt;Let‚Äôs get down to a real example of these ideas. This is a ‚Äòcode kata‚Äô I do every so often. In this particular kata, you get a list of burger orders which looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;[
  { condiments: [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;, &amp;#39;pickles&amp;#39;] },
  { condiments: [&amp;#39;tomatoes&amp;#39;] },
  { condiments: [&amp;#39;mustard&amp;#39;, &amp;#39;ketchup&amp;#39;] },
  // etc...
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You‚Äôre supposed to take this list (of 10,000-some-odd burger variations!) and determine what the top ten most common orders (not just condiments, but orders) are. (The truth is, the list actually mostly looks like &lt;code&gt;condiments: ['ketchup']&lt;/code&gt; over and over again.) So as a preliminary, you can assume that the data is being loaded like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getBurgers = () =&amp;gt;
  fetch(&amp;#39;http://files.example.com/burgers.json&amp;#39;)
    .then(request =&amp;gt; request.json());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we‚Äôll print our results (which will always end up in the same format) like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const descAndCountToOutput = descAndCount =&amp;gt; `${descAndCount[0]}: ${descAndCount[1]}`;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is actually a perfect case to demonstrate how functional programming ideas can help us solve a problem.&lt;/p&gt;
&lt;section id="imperative" class="level3"&gt;
&lt;h3&gt;Imperative&lt;/h3&gt;
&lt;p&gt;First, let‚Äôs look at what I think is a &lt;em&gt;relatively&lt;/em&gt; reasonable imperative approach. Our basic strategy will be:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  let totals = {};

  // 2. Build up a mapping from description to count.
  for (let burger of burgers) {
    // 1. Convert condiments to descriptions.
    // 1.1. Convert the objects to just their lists of condiments.
    const condiments = burger.condiments;
    // 1.2. Sort those strings.
    condiments.sort();
    // 1.3. Turn them into descriptions by joining them with a comma.
    const description = condiments.join(&amp;#39;, &amp;#39;);

    // 2. Build up a mapping from description to count.
    const previousCount = totals[description];
    totals[description] = previousCount ? previousCount + 1 : 1;
  }

  // 3. Sort that by count.
  const sortableCondiments = Object.entries(totals);
  sortableCondiments.sort((a, b) =&amp;gt; b[1] - a[1]);
  // 4. Get the top 10.
  const topTen = sortableCondiments.slice(0, 10);
  // 5. Print out the results.
  for (let descAndCount of topTen) {
    console.log(descAndCountToOutput(descAndCount));
  }
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That‚Äôs pretty well-factored. But it‚Äôs pretty wrapped up on the specific details of this problem, and there‚Äôs basically nothing here I could reuse. It‚Äôs also relatively hard to test. There aren‚Äôt really a lot of pieces there we could break up into smaller functions if we wanted to figure out why something was broken. The way you‚Äôd end up fixing a bug here is probably by dropping &lt;code&gt;debugger&lt;/code&gt; or &lt;code&gt;console.log()&lt;/code&gt; statements in there to see what the values are at any given spot.&lt;/p&gt;
&lt;p&gt;And this is where functional programming really does give us a better way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="functional" class="level3"&gt;
&lt;h3&gt;Functional&lt;/h3&gt;
&lt;p&gt;Instead of thinking about the specific details of &lt;em&gt;how&lt;/em&gt; to get from A to B, let‚Äôs think about what we start with and what we finish with, and see if we can build up a pipeline of transformations that will get us there.&lt;/p&gt;
&lt;p&gt;We start with a &lt;em&gt;list&lt;/em&gt; of &lt;em&gt;objects&lt;/em&gt; containing &lt;em&gt;arrays&lt;/em&gt; of &lt;em&gt;strings&lt;/em&gt;. We want to end up with a &lt;em&gt;list&lt;/em&gt; of the &lt;em&gt;distinct combinations&lt;/em&gt; and their &lt;em&gt;frequency&lt;/em&gt;. How can we do this? Well, the basic idea is the same as what we did above:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To someone acquainted with functional programming, that looks like a bunch of &lt;code&gt;map&lt;/code&gt;s, a &lt;code&gt;reduce&lt;/code&gt;, and some &lt;code&gt;sort&lt;/code&gt;s. And each of those using just simple, pure functions. Let‚Äôs see what that might look like. First, what are our transformations?&lt;/p&gt;
&lt;p&gt;The step 1 transformations are all quite straightforward:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
// 1.1. Convert the objects to just their lists of condiments.
const toCondiments = burger =&amp;gt; burger.condiments ? burger.condiments : [];
// 1.2. Sort those strings.
const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();
// 1.3. Turn them into descriptions by joining them with a comma.
const toDescriptions = condiments =&amp;gt; condiments.join(&amp;#39;, &amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2 is a little more involved: it involves building up a new data structure (&lt;code&gt;totals&lt;/code&gt;) from an old one. This function is a &lt;em&gt;reducer&lt;/em&gt;: it will build up &lt;code&gt;totals&lt;/code&gt; by updating &lt;code&gt;totals&lt;/code&gt; with each &lt;code&gt;description&lt;/code&gt; from an array of them.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 2. Build up a mapping from description to count.
const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  totals[description] = count;
  return totals;
};

// 3. Sort that by count.
const byCount = (a, b) =&amp;gt; b[1] - a[1];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We‚Äôll see how to get just 10 in a moment; for now, let‚Äôs also wrap up the output:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 5. Print it out
const output = value =&amp;gt; { console.log(value); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are our base building blocks, and we‚Äôll re-use them in each of the approaches I cover below. Note that we‚Äôve now taken those same basic steps from our imperative approach and turned them into standalone, testable functions. They‚Äôre small and single-purpose, which always helps. But more importantly, (with two exceptions we‚Äôll talk about in a minute) all of those transformations are &lt;em&gt;pure functions&lt;/em&gt;, we know that we‚Äôll get the same results every time we use them. If I want to make sure that burger condiments are converted correctly, I can test &lt;em&gt;just that function&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;describe(&amp;#39;toCondiments&amp;#39;, () =&amp;gt; {
  it(&amp;#39;returns an empty list when there is no `condiments`&amp;#39;, () =&amp;gt; {
    toCondiments({}).should.deepEqual([]);
  });

  it(&amp;#39;returns the list of condiments when it is passed&amp;#39;, () =&amp;gt; {
    const condiments = [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;];
    toCondiments({ condiments }).should.deepEqual(condiments);
  });
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a trivial example, of course, but it gets the point across: all we have to do to test this is pass in an object. It doesn‚Äôt depend on anything else. It doesn‚Äôt have &lt;em&gt;any knowledge&lt;/em&gt; of how we‚Äôre going to use it. It doesn‚Äôt know that it‚Äôs going to be used with data coming from an array. All it knows is that if you give it an object with a &lt;code&gt;condiments&lt;/code&gt; property, it‚Äôll hand you back the array attached to that property.&lt;/p&gt;
&lt;p&gt;The result is that, with all of these functions, we don‚Äôt have to deal with mocks or stubs or anything like that to be testable. Input produces output. Pure functions are great for this. Now, some of you may be thinking, ‚ÄúThat‚Äôs great, but what about &lt;abbr&gt;I/O&lt;/abbr&gt;, or databases, or any other time we actually interact with the world? What about talking to a point-of-sale?‚Äù I actually have some tentative thoughts about a future tech talk to look at how to do that in some detail, but for today, just remember that the goal is to write as many pure functions as possible, and to isolate the rest of your code from knowing about that. And of course, that‚Äôs best practice anyway! We‚Äôre just codifying it. We‚Äôll see what that looks like in practice in just a minute.&lt;/p&gt;
&lt;p&gt;Now, while we‚Äôre on the topic of pure functions, some of you with quick eyes may have noticed that two of these little functions we laid out are actually &lt;em&gt;not&lt;/em&gt; pure: JavaScript‚Äôs &lt;code&gt;Array.sort&lt;/code&gt; method operates in-place, for performance reasons, and so does our &lt;code&gt;toTotals&lt;/code&gt; function. So a truly pure version of the sorting function looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we &lt;em&gt;could&lt;/em&gt; define the &lt;code&gt;toTotals&lt;/code&gt; to return a new object every time, like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  const update = { [description]: count };
  return Object.assign({}, totals, update);
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, given the amount of data we‚Äôre dealing with, that‚Äôs prohibitively expensive. We end up spending a &lt;em&gt;lot&lt;/em&gt; of time allocating objects and garbage-collecting them. As a result, it‚Äôs tens of thousands of times slower. Running it on my 4GHz iMac, the in-place version takes less than 40ms. Doing it the strictly pure way‚Äîreturning copies every time‚Äîtakes ~53s. And if you profile it, almost all of that time is spent in &lt;code&gt;assign&lt;/code&gt; (52.95s).&lt;/p&gt;
&lt;p&gt;This takes us to an important point, though: it‚Äôs actually not a particularly big deal to have this particular data changed in place, because we‚Äôre not going to do anything &lt;em&gt;else&lt;/em&gt; with it. And in fact, under the hood, this is exactly what pure functional languages do with these kinds of transformations‚Äîprecisely because it‚Äôs perfectly safe to do so, because we‚Äôre the only ones who have access to this data. We‚Äôre generating a &lt;em&gt;new&lt;/em&gt; data structure from the data that we were originally handed, and the next function will make its own new data structure (whether a copy or something else).&lt;/p&gt;
&lt;p&gt;In other words, when we‚Äôre talking about a &lt;em&gt;pure function&lt;/em&gt;, we don‚Äôt really care about internal mutability (though of course, that can bite us if we‚Äôre not careful). We‚Äôre really concerned about &lt;em&gt;external&lt;/em&gt; mutability. As long as the same inputs get the same outputs every time, the rest of the world doesn‚Äôt have to care how we got that result.&lt;/p&gt;
&lt;p&gt;Now let‚Äôs see how we use these functions.&lt;/p&gt;
&lt;section id="pure-javascript" class="level4"&gt;
&lt;h4&gt;Pure JavaScript&lt;/h4&gt;
&lt;p&gt;First, here‚Äôs a pure-JavaScript approach, but a more functional one instead of an imperative one:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const descriptionToCount = burgers
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(toDescriptions)
    .reduce(toTotals, {})

  const entries = Object.entries(descriptionToCount);

  [...entries]
    .sort(byCount)
    .slice(0, 10)  // 4. Get the top 10.
    .map(descAndCountToOutput)
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, the good: our transformation is no longer all jumbled together. In fact, our code reads a lot like our original description did. Also, notice that we just have a bunch of functions operating on data: none of the functions used here have any knowledge about where the data comes from that they operate on.&lt;/p&gt;
&lt;p&gt;But then we also have a couple things that are a &lt;em&gt;little&lt;/em&gt; bit clunky. The main thing that sticks out is that sudden stop in the chain in the middle.&lt;/p&gt;
&lt;p&gt;When we‚Äôre dealing with the &lt;code&gt;Array&lt;/code&gt; type, everything is fine, but when we convert our data into a &lt;code&gt;Map&lt;/code&gt;, we no longer have that option, so we have to jump through some hoops to do the transformation back into the data type we need. We‚Äôre stuck if the object type doesn‚Äôt have the method we need. We‚Äôre kind of trying to mash together the imperative and functional styles, and it‚Äôs leaving us in a little bit of a weird spot.&lt;/p&gt;
&lt;p&gt;There‚Äôs another issue here, though, and it‚Äôs the way that using the method-style calling convention obscures something important. When we call &lt;em&gt;most&lt;/em&gt; of those methods, we‚Äôre doing something quite different from what most &lt;em&gt;methods&lt;/em&gt; do. A method normally is an operation on an object. These methods‚Äîmost of them‚Äîare operations that return &lt;em&gt;new&lt;/em&gt; objects. So it‚Äôs nice from a syntax perspective, but if we‚Äôre not &lt;em&gt;already&lt;/em&gt; familiar with the behavior of a given method, it won‚Äôt be clear at all that we‚Äôre actually generating a bunch of totally new data by calling those methods.&lt;/p&gt;
&lt;p&gt;And‚Ä¶ two of these methods (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt;) &lt;em&gt;are&lt;/em&gt; not doing that, but are modifying an array in place instead.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="lodash" class="level4"&gt;
&lt;h4&gt;Lodash&lt;/h4&gt;
&lt;p&gt;The first step away from this problem is to use a tool like &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// More functional, with _:
// We tweak how a few of these work slightly to play nicely.
const _toDescriptions = condiments =&amp;gt; _.join(condiments, &amp;#39;, &amp;#39;);
const _byCount = _.property(1);

getBurgers().then(burgers =&amp;gt; {
  const condiments = _.map(burgers, toCondiments);
  const sortedCondiments = _.map(condiments, toSortedCondiments);
  const descriptions = _.map(sortedCondiments, _toDescriptions);
  const totals = _.reduce(descriptions, toTotals, {});
  const totalPairs = _.toPairs(totals);
  const sortedPairs = _.sortBy(totalPairs, _byCount);
  const sortedPairsDescending = _.reverse(sortedPairs);
  const topTen = _.take(sortedPairsDescending, 10);
  const forOutput = _.map(topTen, descAndCountToOutput)
  _.forEach(forOutput, output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it seems like we lost something when we moved away from the object-oriented approach. Being able to chain things, so that each item worked with the previous item, was actually pretty nice. And needing all these intermediate variables is &lt;em&gt;not&lt;/em&gt; so nice.&lt;/p&gt;
&lt;p&gt;One way around this is to use Lodash‚Äôs &lt;code&gt;_.chain&lt;/code&gt; method. That would have let us write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const foo = _.chain(burgers)
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(_toDescriptions)
    .reduce(toTotals, {})
    .toPairs()
    .sortBy(_byCount)
    .reverse()
    .take(10)
    .map(descAndCountToOutput)
    .value()
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that &lt;em&gt;is&lt;/em&gt; a win. But it only works because JavaScript is &lt;em&gt;incredibly&lt;/em&gt; dynamic and lets us change the behavior of the underlying &lt;code&gt;Array&lt;/code&gt; type. (You‚Äôd have a much harder time doing that in Java or C&lt;sup&gt;‚ôØ&lt;/sup&gt;!)&lt;/p&gt;
&lt;p&gt;Perhaps just as importantly, it requires us to make sure that we do that &lt;code&gt;_.chain()&lt;/code&gt; call on on anything we want to tackle this way. So, can we get the benefits of this some &lt;em&gt;other&lt;/em&gt; way? Well, obviously the answer is &lt;em&gt;yes&lt;/em&gt; because I wouldn‚Äôt be asking otherwise.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="with-ramda." class="level4"&gt;
&lt;h4&gt;With Ramda.&lt;/h4&gt;
&lt;p&gt;But we can actually go a bit further, and end up in a spot where we don‚Äôt need to modify the object prototype at all. We can just do this with a series of standalone functions which don‚Äôt depend on being attached to &lt;em&gt;any&lt;/em&gt; object. If we use the &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; library,&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; we can tackle this with nothing but functions.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
  R.reduce(toTotals, {}),
  R.toPairs,
  R.sortBy(R.prop(1)),  // will give us least to greatest
  R.reverse,
  R.take(10),
  R.map(descAndCountToOutput)
);

return getBurgers()
  .then(getTop10Burgers)
  .then(R.forEach(output));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice the difference between here and even where we started with Lodash: we‚Äôre no longer dependent on a specific piece of data being present. Instead, we‚Äôve created a standalone function which can operate on that data, simply by ‚Äúpiping‚Äù together‚Äîthat is, &lt;em&gt;composing&lt;/em&gt;‚Äîa bunch of other, smaller functions. The output from each one is used as the input for the next.&lt;/p&gt;
&lt;p&gt;One of the many small niceties that falls out of this is that we can refactor this just by pulling it apart into smaller acts of compositions.&lt;/p&gt;
&lt;p&gt;Here‚Äôs an example of how we might use that. We defined those simple transformations for the condiments as a set of three functions, which converted them from objects with &lt;code&gt;condiments&lt;/code&gt; elements, sorted them, and joined them into a string. Now, let‚Äôs build those into meaningful functions for each step:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
const burgerRecordsToDescriptions = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
);

// 2. Build up a mapping from description to count.
const descriptionsToUniqueCounts = R.pipe(
  R.reduce(toTotals, {}),
  R.toPairs,
);

// 3. Sort that by count.
const uniqueCountsToSortedPairs = R.pipe(
  R.sortBy(R.prop(1)),
  R.reverse,
);

// For (4), to get the top 10, we&amp;#39;ll just use `R.take(10)`.
// We could also alias that, but it doesn&amp;#39;t gain us much.

// 5. Print it out
const sortedPairsToConsole = R.pipe(
  R.map(descAndCountToOutput),
  R.forEach(output)
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can put those together into another, top-level function to do &lt;em&gt;exactly&lt;/em&gt; our steps.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  burgerRecordsToDescriptions,  // (1)
  descriptionsToUniqueCounts,   // (2)
  uniqueCountsToSortedPairs,    // (3)
  R.take(10)                    // (4)
);

getBurgers()
  .then(getTop10Burgers)
  .then(sortedPairsToConsole);  // (5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, because each step is just composing together functions, ‚Äúrefactoring‚Äù is easy. And, to be sure, you have to be mindful about what comes in and out of each function. But that‚Äôs true in the imperative approach, too: you always have to keep track of the state of the object you‚Äôre building up, but there you‚Äôre doing it in the middle of a loop, so you‚Äôre keeping track of a lot &lt;em&gt;more&lt;/em&gt; state at any given time. Functions with simple inputs and outputs give us a more explicit way of specifying the structure and state of the data at any given time. That‚Äôs true even in JavaScript, but it goes double if we‚Äôre in a typed language like F&lt;sup&gt;‚ôØ&lt;/sup&gt;, Elm, etc., where we can specify those types for the function as a way of designing the flow of the program. (That‚Äôs such a helpful way of solving problems, in fact, that I may also do a talk on type-driven design in the future!)&lt;/p&gt;
&lt;p&gt;Note, as well, that we‚Äôve now completely isolated our input and output from everything else. The middle there is a chain of pure functions, built out of other pure functions, which neither know nor care that the data came in from an &lt;abbr&gt;API&lt;/abbr&gt; call, or that we‚Äôre going to print it to the console when we finish.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;So this takes us back around to that first question: why do we care? At the end of the day, is this really a win over the imperative style? Is the final version, using Ramda, really better than the pure-JavaScript mostly-functional version we used at first?&lt;/p&gt;
&lt;p&gt;Obviously, I think the answers there are yes. The Ramda version there at the end is &lt;em&gt;way&lt;/em&gt; better than the imperative version, and substantially better than even the first ‚Äúfunctional‚Äù JavaScript versions we wrote.&lt;/p&gt;
&lt;p&gt;For me, at least, the big takeaway here is this: we just built a small but reasonable transformation of data out of a bunch of really small pieces. That has two big consequences‚Äîconsequences we‚Äôve talked about all along the way, but which you‚Äôve now seen in practice:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Those pieces are easy to test. If something isn‚Äôt working, I can easily take those pieces apart and test them individually, or test the result of any combination of them. As a result, I can test any part of that pipe chain, and I can &lt;em&gt;fix&lt;/em&gt; pieces independent of each other. No part depends on being in the middle of a looper where transformations are done to other parts.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because they‚Äôre small and do one simple things, I can recombine those pieces any way I like. And you see that in the Ramda examples in particular: most of what we‚Äôre doing in those examples is not even something we wrote ourselves. They‚Äôre also &lt;em&gt;really&lt;/em&gt; basic building blocks, available in basically every standard library.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One last thing: if you‚Äôre curious about performance‚Ä¶ you should know that it does matter for data at scale. In my tests (which are admittedly extremely unscientific; unfortunately, I couldn‚Äôt get JSPerf running nicely with this particular set of variations), I found that the time it took to run these varied depending on the approach &lt;em&gt;and&lt;/em&gt; the library. With a ~10k-record data set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The imperative version, unsurprisingly, was the fastest, taking ~16‚Äì17ms.&lt;/li&gt;
&lt;li&gt;After that, the chained lodash version and the pure-&lt;abbr&gt;JS&lt;/abbr&gt; version were comparable, at ~32‚Äì36ms, or around twice as long to finish as the imperative version.&lt;/li&gt;
&lt;li&gt;The plain lodash version was consistently a &lt;em&gt;little&lt;/em&gt; slower yet, at ~38‚Äì43ms.&lt;/li&gt;
&lt;li&gt;Ramda is &lt;em&gt;slow&lt;/em&gt;: both variations consistently took over 90ms to finish.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those differences added up on larger data sets: dealing with ~10,000,000 records, the times ranged from ~12s for the imperative version, to ~15s for the lodash and pure-&lt;abbr&gt;JS&lt;/abbr&gt; variants, to ~50s for the Ramda version.&lt;/p&gt;
&lt;p&gt;They were all pretty darn quick. Compilers, including JavaScript &lt;abbr&gt;JIT&lt;/abbr&gt;s, are incredibly smart. Mostly you can just trust them; come back and profile before you even &lt;em&gt;think&lt;/em&gt; about optimizing things. But you &lt;em&gt;should&lt;/em&gt; know the performance characteristics of different libraries and consider the implications of what the language does well and what it doesn‚Äôt. Ramda is likely slower because of the way it curries every function‚Äîsomething that works well in languages with native support for it, e.g.¬†F&lt;sup&gt;‚ôØ&lt;/sup&gt; or Elm or Haskell, but imposes a penalty in languages which don‚Äôt‚Ä¶ like JavaScript. That said, if you‚Äôre not in the habit of processing tens of thousands of records, you‚Äôre probably okay using any of them.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;or &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt;, but Ramda is a bit better documented and I just like it a little better&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 Nov 2016 22:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-11:/2016/what-is-functional-programming.html</guid><category>software development</category><category>functional programming</category><category>javascript</category></item></channel></rss>