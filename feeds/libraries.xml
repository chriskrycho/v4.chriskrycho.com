<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - libraries</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sat, 19 May 2018 12:20:00 -0400</lastBuildDate><item><title>Destructuring with True Myth 1.3+</title><link>http://www.chriskrycho.com/2018/destructuring-with-true-myth-13.html</link><description>&lt;p&gt;I just realized a neat capability that &lt;a href="#"&gt;True Myth 1.3+&lt;/a&gt; unlocks: you can now use destructuring of the &lt;code&gt;value&lt;/code&gt; property on &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; and the &lt;code&gt;error&lt;/code&gt; property on &lt;code&gt;Error&lt;/code&gt; instances.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Maybe&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing, isJust } from &amp;#39;true-myth/maybe&amp;#39;;

const maybeStrings: Maybe&amp;lt;string&amp;gt;[] =
  [just(&amp;#39;hello&amp;#39;), nothing(), just(&amp;#39;bye&amp;#39;), nothing()];

const lengths = maybeStrings
  .filter(Maybe.isJust)
  .map(({ value }) =&amp;gt; value.length);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;Result&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Result, { ok, err } from &amp;#39;true-myth/result&amp;#39;;

const results: Result&amp;lt;number, string&amp;gt;[] =
  [ok(12), err(&amp;#39;wat&amp;#39;), err(&amp;#39;oh teh noes&amp;#39;), ok(42)];

const okDoubles = results
  .filter(Result.isOk)
  .map(({ value }) =&amp;gt; value * 2);

const errLengths = results
  .filter(Result.isErr)
  .map(({ error }) =&amp;gt; error.length);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;None of this is especially novel or anything. It was just a neat thing to realize after the fact, because it wasn‚Äôt something I had in mind when I was making these changes!&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This was a very strange experience. There‚Äôs nothing quite like learning something about a library &lt;em&gt;you wrote&lt;/em&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 May 2018 12:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-19:/2018/destructuring-with-true-myth-13.html</guid><category>functional programming</category><category>typescript</category><category>open source software</category><category>libraries</category></item><item><title>True Myth 1.3.0 and 2.0.0</title><link>http://www.chriskrycho.com/2018/true-myth-130-and-200.html</link><description>&lt;p&gt;Today I released two versions of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth&lt;/a&gt;: &lt;a href="https://github.com/chriskrycho/true-myth/releases/tag/v1.3.0"&gt;1.3.0&lt;/a&gt; and &lt;a href="https://github.com/chriskrycho/true-myth/releases/tag/v2.0.0"&gt;2.0.0&lt;/a&gt;. You can read the &lt;a href="https://www.chriskrycho.com/2017/announcing-true-myth-10.html"&gt;1.0 announcement&lt;/a&gt; from last November for an overview of the library and a discussion of why you might want to use the library in the first place!&lt;/p&gt;
&lt;p&gt;Since its initial release last November, True Myth has gone through a number of small &lt;a href="https://github.com/chriskrycho/true-myth/releases" title="True Myth releases on GitHub"&gt;feature and bug fix releases&lt;/a&gt;, each of which is more interesting in its own right than 2.0 is‚Äîbecause there are almost no new ‚Äúfeatures‚Äù here, and the changes to the &lt;em&gt;functionality&lt;/em&gt; which are in 2.0 are purely additive and could readily have gone in 1.3 instead.&lt;/p&gt;
&lt;p&gt;In fact, the act of writing that sentence made me realize that there really &lt;em&gt;should&lt;/em&gt; be a 1.3 which people can trivially upgrade to and then take on the changes in 2.0 later.&lt;/p&gt;
&lt;section id="section" class="level2"&gt;
&lt;h2&gt;‚Äì 1.3.0 ‚Äì&lt;/h2&gt;
&lt;p&gt;There are a few very small changes in 1.3 that are just nice ergonomic wins. (You may also be interested in looking back at the &lt;a href="https://github.com/chriskrycho/true-myth/releases"&gt;list of other releases&lt;/a&gt; to see what else has landed since 1.0.)&lt;/p&gt;
&lt;section id="expose-value-and-error" class="level3"&gt;
&lt;h3&gt;Expose &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;value&lt;/code&gt; property in &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Result.Ok&lt;/code&gt; instances, and the &lt;code&gt;error&lt;/code&gt; property in &lt;code&gt;Result.Err&lt;/code&gt; instances, are now &lt;em&gt;public, readonly properties&lt;/em&gt; instead of &lt;em&gt;private properties&lt;/em&gt;. I made those private in the initial implementation because I thought it made more sense to expose them via methods, but experience showed that this is a relatively common pattern in practice:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function dealsWithAMaybe(couldBeAString: Maybe&amp;lt;string&amp;gt;) {
  if (couldBeAString.isJust()) {
    console.log(`It was! ${couldBeAString.unsafelyUnwrap()}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a contrived example of course, but I and my colleagues found in practice that this is a scenario that comes up relatively often, &lt;em&gt;especially&lt;/em&gt; when integrating with existing code rather than writing new code ‚Äì¬†control flow patterns there tend to assume early-return-on-&lt;code&gt;null&lt;/code&gt; or similar instead.&lt;/p&gt;
&lt;p&gt;So I made a change (leaning on TypeScript‚Äôs notion of &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" title="‚ÄúUser-Defined Type Guards‚Äù in the TypeScript handbook"&gt;‚Äútype narrowing‚Äù&lt;/a&gt;) so that you don‚Äôt have to use &lt;code&gt;unsafelyUnwrap&lt;/code&gt; in this scenario anymore! You can use the method types, the standalone functions, or direct matching against the variants on the property&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

function dealsWithAMaybe(maybe: Maybe&amp;lt;string&amp;gt;) {
  if (maybe.isJust()) {
    console.log(`It was! ${maybe.value}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;Result&lt;/code&gt; case this is even nicer (notice that I‚Äôm using the variant, rather than a function, to discriminate between the two and narrow the types here):&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Result, { Variant } from &amp;#39;true-myth/result&amp;#39;;

function dealsWithAResult(result: Result&amp;lt;string, Error&amp;gt;) {
  if (result.variant === Variant.Ok) {
    console.log(`Huzzah: ${result.value}`);
  } else {
    console.log(`Alas: ${result.error.message}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically: you now have more options for handling these scenarios, a nicer &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt;, and‚Äînot that it should &lt;em&gt;usually&lt;/em&gt; matter that much, but for whatever it‚Äôs worth‚Äîbetter performance by way of doing things with property lookups instead of function invocations in quite a few places.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="static-helper-methods" class="level3"&gt;
&lt;h3&gt;Static helper methods&lt;/h3&gt;
&lt;p&gt;At my friend and collaborator &lt;a href="https://mobile.twitter.com/bmakuh"&gt;Ben Makuh&lt;/a&gt;‚Äôs suggestion, I built a couple static helper methods to go with those. These helpers just give you nice abstractions to drop into functional pipelines. For example, you can lean on the type-narrowing capabilities described above while working through a &lt;em&gt;list&lt;/em&gt; of &lt;code&gt;Maybe&lt;/code&gt;s to &lt;em&gt;know&lt;/em&gt; that an item is a &lt;code&gt;Just&lt;/code&gt; and use the new &lt;code&gt;Just.unwrap&lt;/code&gt; static method in the pipeline:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { Just } from &amp;#39;true-myth/maybe&amp;#39;;

function justLengths(maybeStrings: Array&amp;lt;Maybe&amp;lt;string&amp;gt;&amp;gt;) {
  return maybeStrings
    .filter(Maybe.isJust)
.map(Just.unwrap)
    .map(s =&amp;gt; s.length);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Analogous helpers exist for &lt;code&gt;Result&lt;/code&gt; in the form of the &lt;code&gt;Ok.unwrap&lt;/code&gt; and &lt;code&gt;Err.unwrapErr&lt;/code&gt; methods. (&lt;code&gt;Nothing&lt;/code&gt; has no analog for what I hope are obvious reasons!)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="tweaks-to-the-variant-properties" class="level3"&gt;
&lt;h3&gt;Tweaks to the &lt;code&gt;variant&lt;/code&gt; properties&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;variant&lt;/code&gt; property on both &lt;code&gt;Maybe&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; has changed in two ways:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It is now &lt;code&gt;readonly&lt;/code&gt;. This was an implicit invariant previously‚Äîyou would break &lt;em&gt;everything&lt;/em&gt; in the library if you changed the &lt;code&gt;variant&lt;/code&gt; value‚Äîand I‚Äôve just made it explicit in the type system.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It is now properly constrained with a &lt;em&gt;literal type&lt;/em&gt; on the concrete instances. That is, the type of &lt;code&gt;Just.variant&lt;/code&gt; is no longer &lt;code&gt;Variant&lt;/code&gt; but specifically &lt;code&gt;Variant.Just&lt;/code&gt;. (This is what enables you to use the variant for narrowing as demonstrated above. I should have done this in 1.0, and just forgot to!)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that‚Äôs it for 1.3.0!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="section-1" class="level2"&gt;
&lt;h2&gt;‚Äì 2.0.0 ‚Äì&lt;/h2&gt;
&lt;p&gt;The 2.0 release is identical in &lt;em&gt;features&lt;/em&gt; with the 1.3 release. However, it makes a breaking change to how consumers interact with the application, requiring updates to your &lt;code&gt;tsconfig.json&lt;/code&gt; file and your bundler configuration, and removing support for Flow types.&lt;/p&gt;
&lt;section id="configuration-file-updates" class="level3"&gt;
&lt;h3&gt;Configuration file updates&lt;/h3&gt;
&lt;p&gt;Getting True Myth working nicely with consuming TypeScript packages has been a source of frustration for me &lt;em&gt;and&lt;/em&gt; others. In short, requiring you to use the &lt;code&gt;&amp;quot;paths&amp;quot;&lt;/code&gt; key in the &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; section of the &lt;code&gt;tsconfig.json&lt;/code&gt; made for an annoying amount of setup work, &lt;em&gt;and&lt;/em&gt; it meant that using True Myth in a library &lt;em&gt;required&lt;/em&gt; you to set it up in any consuming app. No good.&lt;/p&gt;
&lt;p&gt;For type resolution to Just Work‚Ñ¢, the types &lt;em&gt;must&lt;/em&gt; be at the root of the distributed package.&lt;/p&gt;
&lt;p&gt;As a result, I‚Äôve stopped using &lt;a href="https://github.com/tildeio/libkit"&gt;libkit&lt;/a&gt;, which put the generated types in a reasonable-seeming but (in my experience) painful-to-use place, and have simplified the build layout substantially.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The types themselves are generated only when publishing an update to npm. They go in the root at that point, and they get cleaned up after publishing. (This is pretty much identical to the solution we came up in &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;.)&lt;/li&gt;
&lt;li&gt;The other build files no longer get dropped in a nested &lt;code&gt;src&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;Since I was already at it, I renamed the two build directories from &lt;code&gt;commonjs&lt;/code&gt; to &lt;code&gt;cjs&lt;/code&gt; and from &lt;code&gt;modules&lt;/code&gt; to &lt;code&gt;es&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the distributed build now looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/ 
  index.d.ts
  maybe.d.ts
  result.d.ts
  unit.d.ts
  utils.d.ts
  dist/
    cjs/
      index.js
      maybe.js
      result.js
      unit.js
      utils.js
    es/
      index.js
      maybe.js
      result.js
      unit.js
      utils.js&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You‚Äôll just need to completely remove the &lt;code&gt;&amp;quot;paths&amp;quot;&lt;/code&gt; mapping for True Myth from your &lt;code&gt;tsconfig.json&lt;/code&gt; and, if you‚Äôve done anything unusual with it, update your bundler configuration to point to the new build location, i.e. &lt;code&gt;dist/commonjs/src&lt;/code&gt; should now just be &lt;code&gt;dist/cjs&lt;/code&gt;. Bundlers which respect the &lt;code&gt;modules&lt;/code&gt; key in &lt;code&gt;package.json&lt;/code&gt; will pick it up automatically, as will Ember &lt;abbr&gt;CLI&lt;/abbr&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="removing-flow-types" class="level3"&gt;
&lt;h3&gt;Removing Flow types&lt;/h3&gt;
&lt;p&gt;To my knowledge, no one is actually using the Flow types for the library. When I first started on it, my collaborator &lt;a href="https://github.com/bmakuh"&gt;Ben Makuh&lt;/a&gt; &lt;em&gt;was&lt;/em&gt; using Flow, but he ended up migrating to TypeScript in the intervening time, and there are no consumers I know of. I was always relatively unsure of their correctness, &lt;em&gt;and&lt;/em&gt; I don‚Äôt have a good way to validate their correctness, &lt;em&gt;and&lt;/em&gt; maintaining them involved doing manual work on every release to update the types by hand.&lt;/p&gt;
&lt;p&gt;If you &lt;em&gt;do&lt;/em&gt; use True Myth with Flow, and you‚Äôre missing the types, please let me know. I just can‚Äôt maintain them myself at this point!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;And that‚Äôs it! We‚Äôve been using True Myth in production at Olo for quite some time, and it‚Äôs proved to be a really valuable tool. Give it a spin and let me know how these latest versions work for you!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I‚Äôve made some changes under the hood to take advantage of this as well, so the library should be faster. Probably &lt;em&gt;trivially&lt;/em&gt; faster, but my philosophy around library code is very much &lt;em&gt;be as fast as you can&lt;/em&gt;; it‚Äôs a way of considering the people using your code‚Äînot just the developers, but the end users.&lt;a href="#fnref1" class="footnote-back"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 18 May 2018 19:15:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-18:/2018/true-myth-130-and-200.html</guid><category>TypeScript</category><category>functional programming</category><category>libraries</category><category>software development</category><category>open source software</category><category>versioning</category></item><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I‚Äôm pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I‚Äôve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value‚Äîwhich it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure‚Äîwhich it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself ‚Äì it‚Äôs not hard! ‚Äì¬†but it‚Äôs much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects‚Äîwhich we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you‚Äôre familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them‚Äîits main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren‚Äôt already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default‚Äîit relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don‚Äôt have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we‚Äôd write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn‚Äôt a big deal right here‚Ä¶ but‚Äîand this &lt;em&gt;is&lt;/em&gt; a big deal‚Äîwe have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. üò¨&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;‚Äîas in, ‚ÄúWhat‚Äôs in this field? Just a string‚Äù or ‚ÄúJust the string ‚Äòhello‚Äô‚Äù. If there‚Äôs nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you‚Äôll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it‚Äôs a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it‚Äôs present and do nothing if it isn‚Äôt, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here‚Äôs that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We‚Äôre using TypeScript, so we will get a compiler error if we don‚Äôt handle any of these cases right‚Äîor if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we‚Äôve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That‚Äôs true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you‚Äôre &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn‚Äôt a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat ‚Äúno value‚Äù distinctly from ‚Äúthere‚Äôs a value present, and it‚Äôs an empty string‚Äù? &lt;em&gt;That‚Äôs&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g.¬†Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs incredibly repetitive ‚Äì the very opposite of ‚ÄúDon‚Äôt Repeat Yourself‚Äù. We wouldn‚Äôt do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it‚Äôs not usually the &lt;em&gt;point&lt;/em&gt; of most functions ‚Äì things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we‚Äôre not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can‚Äôt know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it‚Äôs a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it‚Äôs very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there‚Äôs no way for the caller to know that the function will throw. Perhaps you‚Äôre very disciplined and write good docstrings for every function ‚Äì &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone‚Äôs editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data ‚Äì¬†and then you‚Äôre chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you‚Äôre going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can‚Äôt help you here! They don‚Äôt have type signatures to say ‚ÄúThis throws an exception!‚Äù (TypeScript‚Äôs &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
value.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it‚Äôs &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that‚Äôs right away. Maybe we don‚Äôt need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you‚Äôre using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think ‚Äì if there‚Äôs stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it‚Äôs just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category></item></channel></rss>