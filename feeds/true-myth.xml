<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - True Myth</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sun, 02 Sep 2018 16:25:00 -0400</lastBuildDate><item><title>True Myth 2.1.0 Released</title><link>http://www.chriskrycho.com/2018/true-myth-210-released.html</link><description>&lt;p&gt;I‚Äôve just released True Myth 2.1.0 (&lt;a href="https://github.com/chriskrycho/true-myth/tree/v2.1.0"&gt;source&lt;/a&gt;, &lt;a href="https://true-myth.js.org"&gt;docs&lt;/a&gt;), which includes a handful of new utility functions for use with the &lt;code&gt;Maybe&lt;/code&gt; types and arrays or tuples. Note that to make use of these you‚Äôll need to be on at least TypeScript 3.0: they take advantage of the some of the shiny new features in the type system!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; and, five minutes later, versions 2.1.1 and 2.1.2 are out with bugfixes consisting of ‚ÄúI forgot to export two functions. Now they‚Äôre exported.‚Äù Because that‚Äôs how this &lt;em&gt;always&lt;/em&gt; works, right?&lt;/p&gt;
&lt;p&gt;Here‚Äôs what‚Äôs new:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.find&lt;/code&gt;:&lt;/strong&gt; for those times when you want to do &lt;code&gt;Array.prototype.find&lt;/code&gt; and would love to not have to wrap up the result with a &lt;code&gt;Maybe&lt;/code&gt; explicitly every time. As with most functions in True Myth, it‚Äôs curried so you can easily use it in a functional programming style.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

let foundRegular = Maybe.find(n =&amp;gt; n &amp;gt; 1, [1, 2, 3]);
console.log(foundRegular.toString());  // Just(2)

let notFound = Maybe.find(n = n &amp;lt; 1, [1, 2, 3]);
console.log(notFound.toString());  // Nothing

let findAtLeast5 = Maybe.find((n: number) =&amp;gt; n &amp;gt; 5);
let foundCurried = findAtLeastFive([2, 4, 6, 8, 10]);
console.log(foundCurried.toString());  // Just(6)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.head&lt;/code&gt; (aliased as &lt;code&gt;Maybe.first&lt;/code&gt;):&lt;/strong&gt; for getting the first item of an array safely. Like lodash‚Äôs &lt;code&gt;_.head&lt;/code&gt; (or &lt;code&gt;someArray[0]&lt;/code&gt;) but it returns a &lt;code&gt;Maybe&lt;/code&gt; instead of possibly giving you back &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

let empty = Maybe.head([]);
console.log(empty.toString());  // Nothing

let hasItems = Maybe.head([1, 2, 3]);
console.log(hasItems.toString());  // Just(1)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.last&lt;/code&gt;:&lt;/strong&gt; the same as &lt;code&gt;Maybe.head&lt;/code&gt;, but for getting the &lt;em&gt;last&lt;/em&gt; element in an array.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

let empty = Maybe.last([]);
console.log(empty.toString());  // Nothing

let hasItems = Maybe.last([1, 2, 3]);
console.log(hasItems.toString());  // Just(3)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.all&lt;/code&gt;:&lt;/strong&gt; for converting an array of &lt;code&gt;Maybe&lt;/code&gt;s to a &lt;code&gt;Maybe&lt;/code&gt; of an array. If you have an array whose contents are all &lt;code&gt;Maybe&lt;/code&gt;s, it‚Äôs sometimes useful to be able to flip that around so that if all of the items are &lt;code&gt;Just&lt;/code&gt;s, you get back a single &lt;code&gt;Just&lt;/code&gt; wrapping the array of the values which were wrapped in all the &lt;code&gt;Just&lt;/code&gt;s in the array, but if any were &lt;code&gt;Nothing&lt;/code&gt;, the whole thing is a single &lt;code&gt;Nothing&lt;/code&gt;. This works for both heterogeneous and homogenous arrays, which is pretty cool. A code sample will make this a lot clearer:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing } from &amp;#39;true-myth/maybe&amp;#39;;

let includesNothing = Maybe.all(just(2), nothing&amp;lt;string&amp;gt;());
console.log(includesNothing.toString());  // Nothing

let allJusts = Maybe.all(just(2), just(&amp;#39;hi&amp;#39;), just([42]));
console.log(allJusts.toString());  // Just([2, &amp;#39;hi&amp;#39;, [42]]);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting type of both &lt;code&gt;includesNothing&lt;/code&gt; and &lt;code&gt;allJusts&lt;/code&gt; here is &lt;code&gt;Maybe&amp;lt;Array&amp;lt;string | number | Array&amp;lt;number&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.tuple&lt;/code&gt;:&lt;/strong&gt; just like &lt;code&gt;Maybe.all&lt;/code&gt; except it works in tuples (preserving their types‚Äô order) for up to five-item tuples. (As the docs I wrote say: if you‚Äôre doing a larger tuple than that I don‚Äôt want to know what you‚Äôre doing but I won‚Äôt help with it!)&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing } from &amp;#39;true-myth/maybe&amp;#39;;

type Tuple = [Maybe&amp;lt;number&amp;gt;, Maybe&amp;lt;string&amp;gt;, Maybe&amp;lt;number[]&amp;gt;];

let tupleWithNothing: Tuple = [just(2), nothing(), just([42])];
let tupleResult = Maybe.tuple(tupleWithNothing);
console.log(tupleResult.toString());  // Nothing

let allJusts: Tuple = [just(2), just(), just([42])];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These have the same &lt;em&gt;output&lt;/em&gt; (i.e.¬†the same underlying representation) as the array output, but a different type. The resulting type of both &lt;code&gt;includesNothing&lt;/code&gt; and &lt;code&gt;allJusts&lt;/code&gt; here is &lt;code&gt;Maybe&amp;lt;[number, string, Array&amp;lt;number&amp;gt;]&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once TypeScript 3.1 is out, I should be able to collapse these into a single &lt;code&gt;all&lt;/code&gt;, and &lt;code&gt;tuple&lt;/code&gt; will just become an alias for it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 02 Sep 2018 16:25:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-09-02:/2018/true-myth-210-released.html</guid><category>TypeScript</category><category>functional programming</category><category>monads</category><category>libraries</category><category>software development</category><category>open source software</category><category>True Myth</category></item><item><title>Stable Libraries</title><link>http://www.chriskrycho.com/2018/stable-libraries.html</link><description>&lt;p&gt;&lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth&lt;/a&gt; has changed very little since I first released it, and although I have a few ideas for small additions I might make, I don‚Äôt really expect it to change much in the future. &lt;em&gt;That‚Äôs okay.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There‚Äôs a strange idea in some parts of the software development ecosystem‚Äîa way of think I also find myself falling into from time‚Äîwhich takes a lack of changes to a library as a sign that the library is &lt;em&gt;dead&lt;/em&gt; and shouldn‚Äôt be used. I call this idea ‚Äústrange‚Äù because if you take a step back, it‚Äôs actually not necessarily very healthy for certain kinds of libraries to be changing all the time.&lt;/p&gt;
&lt;p&gt;But if you‚Äôre in an ecosystem where rapid change in libraries is normal, you end up assuming that something which &lt;em&gt;isn‚Äôt changing&lt;/em&gt; is &lt;em&gt;unmaintained&lt;/em&gt; or &lt;em&gt;not usable&lt;/em&gt; when in fact the opposite may be true. If someone opens a pull request or an issue for True Myth, I generally get to it in under a day, often under an hour if it‚Äôs in my normal working time. (That‚Äôs easy enough for me to do because it‚Äôs a small, simple library; I don‚Äôt have the scale problems that larger projects do.) The project isn‚Äôt &lt;em&gt;dead&lt;/em&gt;. It‚Äôs just mostly &lt;em&gt;done&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One of the things I‚Äôd like to see in the front-end/JavaScript community in particular is a growing embrace of the idea that some libraries can genuinely be finished. They might need a tweak here or there to work with a new packaging solution, or to fix some corner case bug that has been found. But the ‚Äúchurn‚Äù we all feel to varying degrees would be much diminished if maintainers didn‚Äôt feel a constant push to be changing for the sake of, well‚Ä¶ change. The burden on maintainers would be lower, too. Maybe we‚Äôd all get to spend less time on small changes that just keep us ‚Äúup to date‚Äù and more on solving bigger problems.&lt;/p&gt;
&lt;p&gt;Don‚Äôt get me wrong: sometimes changing perspective warrants a rewrite. But in libraries as in apps, just as often you‚Äôll end up with a bad case of &lt;a href="https://en.m.wikipedia.org/wiki/Second-system_effect"&gt;second system syndrome&lt;/a&gt;; and rewrites are &lt;em&gt;rarely&lt;/em&gt;‚Äînot never, but rarely‚Äîclean wins.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 14 Aug 2018 19:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-08-14:/2018/stable-libraries.html</guid><category>software development</category><category>open source software</category><category>libraries</category><category>true myth</category><category>javascript</category></item><item><title>How To Bundle TypeScript Type Definitions</title><link>http://www.chriskrycho.com/2018/how-to-bundle-typescript-type-definitions.html</link><description>&lt;p&gt;One of the lessons that led to the True Myth 2.0.0 release was the difficulty of consuming the library under its original packaging strategy. There are a few things that are &lt;em&gt;not&lt;/em&gt; obvious about how TypeScript type definitions get consumed when you‚Äôre first starting out, and a few things that seem like they should work &lt;em&gt;don‚Äôt&lt;/em&gt;. This is my attempt to help &lt;em&gt;you&lt;/em&gt; (and the people consuming your TypeScript libraries!) avoid the same pain I (and the people consuming mine) have felt.&lt;/p&gt;
&lt;section id="the-problem" class="level2"&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem is the result of the ways TypeScript resolves type definitions, and the kinds of type definition files it can (and cannot) generate for you.&lt;/p&gt;
&lt;p&gt;TypeScript only properly resolves two kinds of type definition distributions automatically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single-file type definition, located anywhere in the package as long as &lt;code&gt;package.json&lt;/code&gt; has a &lt;code&gt;types&lt;/code&gt; key pointing to it.&lt;/li&gt;
&lt;li&gt;Type definition module files in the &lt;em&gt;root&lt;/em&gt; of the distributed package, mapping to the distributed modules of the package (wherever they live).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TypeScript will only generate a single-file type definition for the &lt;abbr&gt;AMD&lt;/abbr&gt; and SystemJS standards‚Äîwhich &lt;em&gt;cannot&lt;/em&gt; be imported with ES6 module imports. If you want to use an output mode which generates a JS file per originating TS file‚ÄîNode, ES6, etc.‚Äîyou will get individual TS module file type definitions as well. It is not that the type definition files themselves can‚Äôt be written to support Node or ES6-style module layouts in a single-file definition. To the contrary: hand-written definitions for libraries &lt;em&gt;often&lt;/em&gt; do just that. It is just a matter of what the compiler supports generating.&lt;/p&gt;
&lt;p&gt;The net of this is: if you want module type definitions to go with ES6 modules to import, they &lt;em&gt;must&lt;/em&gt; live in the root of your distributed bundle.&lt;/p&gt;
&lt;p&gt;However, most libraries I‚Äôm familiar with‚Äîbecause I work in the &lt;em&gt;browser&lt;/em&gt; ecosystem, not the &lt;em&gt;Node&lt;/em&gt; ecosystem‚Äîdo not work with the root of their repository as the place where their source lives, or for the place where the output of their build process lives. It‚Äôs far more common to have a &lt;code&gt;src&lt;/code&gt; directory and &lt;code&gt;dist&lt;/code&gt; or &lt;code&gt;build&lt;/code&gt; directory, the latter of which is where the build artifacts go.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-solution" class="level2"&gt;
&lt;h2&gt;The Solution&lt;/h2&gt;
&lt;p&gt;The solution‚Äîwhich we shipped for ember-cli-typescript some time ago, and which I switched to this past week for True Myth‚Äîis to have separate build artifacts for the type definitions and the JavaScript output. Put the JavaScript output in the &lt;code&gt;dist&lt;/code&gt; or &lt;code&gt;build&lt;/code&gt; directory as usual, without type declarations. Then, put the type definitions in the root of the repository.&lt;/p&gt;
&lt;p&gt;In the case of both ember-cli-typescript and True Myth, we‚Äôre doing the type generation step in the &lt;code&gt;prepublishOnly&lt;/code&gt; hook and cleaning it up in the &lt;code&gt;postpublish&lt;/code&gt; hook. Your &lt;code&gt;package.json&lt;/code&gt; might look like something like this, assuming your &lt;code&gt;tsconfig.json&lt;/code&gt; is set to generate JavaScript artifacts in &lt;code&gt;dist&lt;/code&gt; as your build directory.&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;ts:js&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;ts:defs&amp;quot;: &amp;quot;tsc --declaration --outDir . --emitDeclarationOnly&amp;quot;,
    &amp;quot;prepublishOnly&amp;quot;: &amp;quot;yarn ts:js &amp;amp;&amp;amp; yarn ts:defs&amp;quot;,
    &amp;quot;postpublish&amp;quot;: &amp;quot;rm -r *.d.ts dist&amp;quot;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(If you have nested modules, your &lt;code&gt;postpublish&lt;/code&gt; hook there should clean up the generated folders as well as the generated files.)&lt;/p&gt;
&lt;p&gt;You can see the full setup I built for True Myth‚Äîwhich generates type defs along these lines, as well as both CommonJS and ES6 modules‚Äîin the repository:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/package.json"&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt;‚Äînote especially the &lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/package.json#L32:L42"&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;&lt;/code&gt;&lt;/a&gt; configuration&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/tsconfig.json"&gt;root &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt;, with derived&lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/ts/cjs.tsconfig.json"&gt;CommonJS &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/ts/es.tsconfig.json"&gt;ES6 &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;This isn‚Äôt an especially complicated thing, but the scenario leading to the need for this is common enough, and the dance frustrating enough and easy enough to get wrong, that I really wish the TypeScript team would make it possible to generate single-file type definitions for &lt;em&gt;all&lt;/em&gt; kinds of JavaScript module systems.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 21 May 2018 07:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-21:/2018/how-to-bundle-typescript-type-definitions.html</guid><category>typescript</category><category>programming languages</category><category>true myth</category></item><item><title>Destructuring with True Myth 1.3+</title><link>http://www.chriskrycho.com/2018/destructuring-with-true-myth-13.html</link><description>&lt;p&gt;I just realized a neat capability that &lt;a href="#"&gt;True Myth 1.3+&lt;/a&gt; unlocks: you can now use destructuring of the &lt;code&gt;value&lt;/code&gt; property on &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; and the &lt;code&gt;error&lt;/code&gt; property on &lt;code&gt;Error&lt;/code&gt; instances.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Maybe&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing, isJust } from &amp;#39;true-myth/maybe&amp;#39;;

const maybeStrings: Maybe&amp;lt;string&amp;gt;[] =
  [just(&amp;#39;hello&amp;#39;), nothing(), just(&amp;#39;bye&amp;#39;), nothing()];

const lengths = maybeStrings
  .filter(Maybe.isJust)
  .map(({ value }) =&amp;gt; value.length);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;Result&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Result, { ok, err } from &amp;#39;true-myth/result&amp;#39;;

const results: Result&amp;lt;number, string&amp;gt;[] =
  [ok(12), err(&amp;#39;wat&amp;#39;), err(&amp;#39;oh teh noes&amp;#39;), ok(42)];

const okDoubles = results
  .filter(Result.isOk)
  .map(({ value }) =&amp;gt; value * 2);

const errLengths = results
  .filter(Result.isErr)
  .map(({ error }) =&amp;gt; error.length);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;None of this is especially novel or anything. It was just a neat thing to realize after the fact, because it wasn‚Äôt something I had in mind when I was making these changes!&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This was a very strange experience. There‚Äôs nothing quite like learning something about a library &lt;em&gt;you wrote&lt;/em&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 May 2018 12:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-19:/2018/destructuring-with-true-myth-13.html</guid><category>functional programming</category><category>typescript</category><category>open source software</category><category>libraries</category><category>true myth</category></item><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I‚Äôm pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I‚Äôve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value‚Äîwhich it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure‚Äîwhich it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself ‚Äì it‚Äôs not hard! ‚Äì¬†but it‚Äôs much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects‚Äîwhich we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you‚Äôre familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them‚Äîits main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren‚Äôt already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default‚Äîit relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don‚Äôt have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we‚Äôd write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn‚Äôt a big deal right here‚Ä¶ but‚Äîand this &lt;em&gt;is&lt;/em&gt; a big deal‚Äîwe have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. üò¨&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;‚Äîas in, ‚ÄúWhat‚Äôs in this field? Just a string‚Äù or ‚ÄúJust the string ‚Äòhello‚Äô‚Äù. If there‚Äôs nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you‚Äôll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it‚Äôs a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it‚Äôs present and do nothing if it isn‚Äôt, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here‚Äôs that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We‚Äôre using TypeScript, so we will get a compiler error if we don‚Äôt handle any of these cases right‚Äîor if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we‚Äôve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That‚Äôs true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you‚Äôre &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn‚Äôt a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat ‚Äúno value‚Äù distinctly from ‚Äúthere‚Äôs a value present, and it‚Äôs an empty string‚Äù? &lt;em&gt;That‚Äôs&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g.¬†Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs incredibly repetitive ‚Äì the very opposite of ‚ÄúDon‚Äôt Repeat Yourself‚Äù. We wouldn‚Äôt do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it‚Äôs not usually the &lt;em&gt;point&lt;/em&gt; of most functions ‚Äì things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we‚Äôre not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can‚Äôt know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it‚Äôs a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it‚Äôs very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there‚Äôs no way for the caller to know that the function will throw. Perhaps you‚Äôre very disciplined and write good docstrings for every function ‚Äì &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone‚Äôs editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data ‚Äì¬†and then you‚Äôre chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you‚Äôre going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can‚Äôt help you here! They don‚Äôt have type signatures to say ‚ÄúThis throws an exception!‚Äù (TypeScript‚Äôs &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
value.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it‚Äôs &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that‚Äôs right away. Maybe we don‚Äôt need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you‚Äôre using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think ‚Äì if there‚Äôs stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it‚Äôs just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category><category>true myth</category></item></channel></rss>