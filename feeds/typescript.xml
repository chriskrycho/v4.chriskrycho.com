<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - typescript</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Wed, 01 Nov 2017 08:40:00 -0400</lastBuildDate><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I‚Äôm pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I‚Äôve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value‚Äîwhich it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure‚Äîwhich it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself ‚Äì it‚Äôs not hard! ‚Äì¬†but it‚Äôs much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects‚Äîwhich we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you‚Äôre familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them‚Äîits main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren‚Äôt already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default‚Äîit relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don‚Äôt have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we‚Äôd write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn‚Äôt a big deal right here‚Ä¶ but‚Äîand this &lt;em&gt;is&lt;/em&gt; a big deal‚Äîwe have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. üò¨&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;‚Äîas in, ‚ÄúWhat‚Äôs in this field? Just a string‚Äù or ‚ÄúJust the string ‚Äòhello‚Äô‚Äù. If there‚Äôs nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you‚Äôll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it‚Äôs a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it‚Äôs present and do nothing if it isn‚Äôt, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here‚Äôs that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We‚Äôre using TypeScript, so we will get a compiler error if we don‚Äôt handle any of these cases right‚Äîor if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we‚Äôve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That‚Äôs true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you‚Äôre &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn‚Äôt a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat ‚Äúno value‚Äù distinctly from ‚Äúthere‚Äôs a value present, and it‚Äôs an empty string‚Äù? &lt;em&gt;That‚Äôs&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g.¬†Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs incredibly repetitive ‚Äì the very opposite of ‚ÄúDon‚Äôt Repeat Yourself‚Äù. We wouldn‚Äôt do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it‚Äôs not usually the &lt;em&gt;point&lt;/em&gt; of most functions ‚Äì things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we‚Äôre not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can‚Äôt know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it‚Äôs a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it‚Äôs very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there‚Äôs no way for the caller to know that the function will throw. Perhaps you‚Äôre very disciplined and write good docstrings for every function ‚Äì &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone‚Äôs editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data ‚Äì¬†and then you‚Äôre chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you‚Äôre going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can‚Äôt help you here! They don‚Äôt have type signatures to say ‚ÄúThis throws an exception!‚Äù (TypeScript‚Äôs &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
Result.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it‚Äôs &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that‚Äôs right away. Maybe we don‚Äôt need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you‚Äôre using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think ‚Äì if there‚Äôs stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it‚Äôs just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category></item><item><title>Announcing ember-cli-typescript 1.0.0</title><link>http://www.chriskrycho.com/2017/announcing-ember-cli-typescript-100.html</link><description>&lt;p&gt;I‚Äôm extremely pleased to announce the release of &lt;a href="https://github.com/typed-ember/ember-cli-typescript/releases/tag/v1.0.0"&gt;ember-cli-typescript 1.0.0&lt;/a&gt;! You can get it the same way you do &lt;em&gt;any&lt;/em&gt; Ember addon:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;$ ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a detailed walkthrough of adding TypeScript to your projects, see:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-1.html"&gt;Typing Your Ember, Part 1: Set your Ember.js project up to use TypeScript.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-2.html"&gt;Typing Your Ember, Part 2: Adding TypeScript to an existing Ember.js project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what are we shipping today, and what‚Äôs on the roadmap?&lt;/p&gt;
&lt;section id="whats-in-1.0" class="level2"&gt;
&lt;h2&gt;What‚Äôs In 1.0?&lt;/h2&gt;
&lt;p&gt;This release is intentionally relatively minimal: the goal here is provide stable foundation for building Ember.js applications with TypeScript in the toolchain. This means that in any app you can install the add-on and just start &lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-3.html"&gt;progressively converting your app over to TypeScript&lt;/a&gt;. However, we don‚Äôt expect to change the way you &lt;em&gt;use&lt;/em&gt; the addon at all in the foreseeable future.&lt;/p&gt;
&lt;p&gt;I‚Äôll give you fair warning that there is one &lt;em&gt;major&lt;/em&gt; challenge you will find as you work with ember-cli-typescript today: the lack of type definitions for most projects, and the limits of the existing type definitions for Ember.js itself. That‚Äôs not as bad as it sounds, though:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;See the &lt;a href="#the-roadmap"&gt;&lt;strong&gt;Roadmap&lt;/strong&gt;&lt;/a&gt; below‚Äîwe‚Äôre working on that, and you can help!&lt;/li&gt;
&lt;li&gt;I‚Äôve been using TypeScript successfully in the app I work on at my day job for the last nine months or so. While the lack of (good or any) typings has had its frustrations, &lt;a href="https://www.dailydrip.com/blog/domain-driven-design-and-typed-functional-programming-in-typescript"&gt;TypeScript has already added a &lt;em&gt;lot&lt;/em&gt; of value for us&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;section id="the-roadmap" class="level2"&gt;
&lt;h2&gt;The Roadmap&lt;/h2&gt;
&lt;p&gt;We have a bunch of things we‚Äôre actively working on and which you can expect to land in the next few weeks to months.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1-1-a-prepublish-build-process-for-addons"&gt;1.1: A prepublish build process for addons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#community-driven-work-on-typings"&gt;Community-driven work on typings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="a-prepublish-build-process-for-addons" class="level3"&gt;
&lt;h3&gt;1.1: A prepublish build process for addons&lt;/h3&gt;
&lt;p&gt;The major priority for the 1.1 release is an npm prepublication step to generate JavaScript and typing files from add-ons which are using TypeScript. Currently, addons have to take TypeScript as a full dependency, not a dev dependency, because they currently just ship the &lt;code&gt;.ts&lt;/code&gt; files up to npm and they have to be compiled in your app at build time.&lt;/p&gt;
&lt;p&gt;We really don‚Äôt want to make any app developer who is using your addon download either the TypeScript files or &lt;em&gt;especially&lt;/em&gt; the TypeScript compiler if we can avoid it. There are three reasons for this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;The fact that an add-on is developed in TypeScript really shouldn‚Äôt affect app developers. If they‚Äôre writing a plain-old JavaScript app, the fact that your addon is originally written in TypeScript is irrelevant to them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TypeScript is &lt;em&gt;large&lt;/em&gt;. The v2.4 installation I have in the app I‚Äôm working on right now weights 26MB. If I were using four add-ons which required TypeScript, my install cost could easily go up by a hundred megabytes. That‚Äôs not always a huge deal on a corporate network, but even where people &lt;em&gt;do&lt;/em&gt; have good download speeds, it‚Äôs a hit to developer time. Every time someone has to reinstall all the dependencies, those 26MB have to come down again. If TypeScript becomes common, you might suddenly find yourself with addons using 2.4, 2.5, 2.6, etc.; it‚Äôs not hard to see that ballooning up the size of your installation in a really non-trivial way: 26MB √ó &lt;em&gt;n&lt;/em&gt; versions of TypeScript = &lt;em&gt;do not want&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The TypeScript compilation step takes time. Addons can do this &lt;em&gt;once&lt;/em&gt; and save every consuming app build time. This isn‚Äôt the end of the world, but anything we can do to keep build times lower is a real win for developer productivity.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Accordingly the plan is to automatically add a build step which runs the TypeScript compiler on your addon and generates plain-old-JavaScript and the corresponding type definition files (&lt;code&gt;.d.ts&lt;/code&gt;) prior to publishing to npm. That way, TypeScript can remain a dev dependency (rather than a full dependency) of each addon, and not be installed alongside the addon for consumers. Just-JavaScript consumers can just consume the normal JavaScript generated by the build. TypeScript consumers will get the full benefits of the types via the generated typing files.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;should&lt;/em&gt; hopefully land by late August or early September. Fingers crossed.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="community-driven-work-on-typings" class="level3"&gt;
&lt;h3&gt;Community-driven work on typings&lt;/h3&gt;
&lt;p&gt;The process of getting type definitions in place for &lt;em&gt;all&lt;/em&gt; of Ember.js and its ecosystem is way, &lt;em&gt;way&lt;/em&gt; too big for any one person or even a small handful of people to manage alone. This is something we‚Äôre going to take on as a community.&lt;/p&gt;
&lt;section id="new-typings-for-ember.js-itself" class="level4"&gt;
&lt;h4&gt;New typings for Ember.js itself&lt;/h4&gt;
&lt;p&gt;We‚Äôre actively working on type definitions for Ember which will give us actually-useful-and-correct type checking for Ember‚Äôs custom object model. Today, if you use &lt;code&gt;Ember.get&lt;/code&gt; or &lt;code&gt;Ember.set&lt;/code&gt;, you get &lt;em&gt;no&lt;/em&gt; help from the type system. When we finish, those will be type-checked by the compiler and will error if you try to assign the wrong values!&lt;/p&gt;
&lt;p&gt;Importantly, the typings we‚Äôre shipping will be backwards compatible with the existing Ember API, but will also include support for the &lt;a href="https://github.com/emberjs/rfcs/pull/176"&gt;RFC #176 JavaScript Modules API&lt;/a&gt;. TypeScript‚Äôs module definition system will let us support both in parallel, and we will. Backwards compatibility and &lt;em&gt;stability without stagnation&lt;/em&gt; are things we value for this addon just as much as the rest of the Ember.js ecosystem does.&lt;/p&gt;
&lt;p&gt;This effort, led by Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;), is ongoing in the &lt;a href="https://github.com/typed-ember/ember-typings"&gt;typed-ember/ember-typings&lt;/a&gt; repository. (If you‚Äôre wondering why we‚Äôre not just doing it in the DefinitelyTyped repository, see below.) We probably won‚Äôt be able to get to 100% of everything the Ember Object model does‚ÄîEmber‚Äôs custom object model is &lt;em&gt;incredibly&lt;/em&gt; sophisticated, and TypeScript actually &lt;a href="https://github.com/Microsoft/TypeScript/issues/16699"&gt;still can‚Äôt&lt;/a&gt; &lt;em&gt;totally&lt;/em&gt; express it‚Äîbut Derek already has most of it working. This will be a &lt;em&gt;huge&lt;/em&gt; step forward.&lt;/p&gt;
&lt;p&gt;To be clear, we‚Äôre not forking the way you get types. We‚Äôll upstream all of this work to DefinitelyTyped as soon as we have them working, but the DefinitelyTyped repo is &lt;em&gt;huge&lt;/em&gt; and very busy; it‚Äôs not a great place to do this kind of substantial rework of existing types. And we really don‚Äôt need to have all the &lt;em&gt;other&lt;/em&gt; type definitions DefinitelyTyped supplies in our way as we‚Äôre working, either. Having a separate repo gives us a place we can work on types, try them out as a community, etc. before creating PRs on DefinitelyTyped and publishing them officially.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="addon-typings" class="level4"&gt;
&lt;h4&gt;Addon typings&lt;/h4&gt;
&lt;p&gt;We need to get type definitions in place for the addons in the ecosystem! That way when you‚Äôre using, say, &lt;a href="https://github.com/simplabs/ember-test-selectors"&gt;ember-test-selectors&lt;/a&gt;, you‚Äôll get an error if you try to use the functions it provides incorrectly. Right now, every addon out there is missing types entirely, so everything gets treated as taking the useless &lt;code&gt;any&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;In a week or so, I‚Äôll have a blog post with a fleshed-out &lt;a href="https://github.com/typed-ember/ember-cli-typescript/issues/48"&gt;quest issue&lt;/a&gt; for tackling it in detail, but here‚Äôs the short version: we‚Äôre going to try to get type definitions for all the top addons in the ecosystem so that it‚Äôs &lt;em&gt;easy&lt;/em&gt; to use TypeScript in your Ember.js app. That blog post and quest issue will explain how to write good typings, and also how to contribute them to a project which may or may not be interested in using TypeScript itself.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 08 Aug 2017 09:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-08-08:/2017/announcing-ember-cli-typescript-100.html</guid><category>typing-your-ember</category><category>typescript</category><category>emberjs</category></item><item><title>Typing Your Ember, Part 4</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-4.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I‚Äôll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today‚Äîand I‚Äôll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. ‚Üí)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-3"&gt;previous post&lt;/a&gt; in this series, I noted that one of the most effective current strategies for using TypeScript effectively in an Ember app is to push as much of your logic possible &lt;em&gt;out&lt;/em&gt; of the Ember layer and into plain-old-TypeScript. Unsurprisingly, people had some questions about how to do this, so here‚Äôs a brief example.&lt;/p&gt;
&lt;p&gt;As I suggested in that post, we now have a &lt;code&gt;lib&lt;/code&gt; directory in our app, and all new business logic for the app lives there instead of directly on e.g.¬†an &lt;code&gt;Ember.Service&lt;/code&gt; instance. Our current directory structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app/
  adapters/
  components/
  config/
  controllers/
  helpers/
  initializers/
  instance-initializers
  lib/    &amp;lt;-- this is the one we care about
    billing/
    utilities/
      numeric.ts
  routes/
  serializers/
  services/
  templates/
  transforms
  app.ts
  router.ts
tests/
package.json
bower.json
// etc.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main thing to notice here is that &lt;code&gt;lib&lt;/code&gt; is just a directory in the app like any other, and its child directories likewise. This means that Ember &lt;abbr title="command line interface"&gt;CLI&lt;/abbr&gt; will resolve it just like normal, too‚Äîthere‚Äôs no need to mess with the resolver or anything.&lt;/p&gt;
&lt;p&gt;Say we had a set of numeric utilities in that &lt;code&gt;numeric.ts&lt;/code&gt; file like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Make text out of numbers, like &amp;quot;1st&amp;quot;, &amp;quot;2nd&amp;quot;, &amp;quot;3rd&amp;quot;, etc.
export const withEnding = (val: number): string =&amp;gt; {
  // boring implementation details elided
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then using it in an Ember component might look like this (where &lt;code&gt;currentNumber&lt;/code&gt; is passed into the component):&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { get, set } from &amp;#39;@ember/object&amp;#39;;
import * as Num from &amp;#39;../lib/utilities/numeric&amp;#39;;

export default Component.extend({
  init() {
    const currentNumber = get(this, &amp;#39;currentNumber&amp;#39;);
    const displayNumber = Num.withEnding(currentNumber);
    set(this, &amp;#39;displayNumber&amp;#39;, displayNumber);
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might wonder why we‚Äôd do this instead of using an &lt;code&gt;Ember.Service&lt;/code&gt;. In the above example, I could of course make &lt;code&gt;Num&lt;/code&gt; a service and inject it‚Ä¶&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { getProperties, set } from &amp;#39;@ember/object&amp;#39;;
import { inject } from &amp;#39;@ember/service&amp;#39;;

export default Component.extend({
  num: inject(),

  init() {
    const { currentNumber, num } =
      getProperties(this, &amp;#39;currentNumber&amp;#39;, &amp;#39;num&amp;#39;);

    const displayNumber = num.withEnding(currentNumber);
    set(this, &amp;#39;displayNumber&amp;#39;, displayNumber);
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;‚Ä¶but that doesn‚Äôt actually &lt;em&gt;gain&lt;/em&gt; me anything‚Äîthe service here is just a way of exposing a function, after all‚Äîand it actually makes everything a bit more verbose. It also decreases the overall analyzability of this for things like tree-shaking: that module dependency is now something that Ember itself has to manage, instead of being statically analyzable at build time. Taking this approach also diminishes the reusability of any numeric helpers I put in there. If we couple them to an &lt;code&gt;Ember.Service&lt;/code&gt;, instead of using an ES6 module, they would stop being things we can easily reuse in non-Ember projects. Instead, by using modules, we leave ourselves the ability to easily extract those numeric helpers, and publish them for either internal or external consumption.&lt;/p&gt;
&lt;p&gt;Along those lines, we actually have a module to support &lt;abbr title="Block-Element-Modifier"&gt;&lt;a href="https://en.bem.info/methodology/quick-start/"&gt;BEM&lt;/a&gt;&lt;/abbr&gt; with Ember Components‚Äîand we plan to extract both the basic TypeScript library as well as a &lt;code&gt;BemComponent&lt;/code&gt; Ember-specific wrapper as open-source libraries in the near future. Besides the Ember addon, &lt;em&gt;anyone&lt;/em&gt; will be able to consume and use the underlying TypeScript library, whatever their framework or library of choice. Importantly, that includes us in our other codebases, which include lots of old jQuery and some new React, and might include some Glimmer.js in the future. Any or all of our utilities for these kinds of things become reusable if they‚Äôre just TypeScript.&lt;/p&gt;
&lt;p&gt;Pragmatically, it‚Äôs also just easier to do and get good help from TypeScript by going this way. It also means that unit-testing requires &lt;em&gt;no&lt;/em&gt; context from Ember whatsoever, which keeps those tests lighter and faster. Even though Ember‚Äôs unit tests are already super quick, when you have hundreds or thousands of unit tests, every little bit matters. It also, and probably even more importantly, means there are fewer places where you could mess things up when configuring tests‚Äînot that I have any experience messing up test configurations in Ember!&lt;/p&gt;
&lt;p&gt;One important thing to note is that this all works best with Ember‚Äîby far‚Äîwhen your &lt;code&gt;lib&lt;/code&gt; modules aren‚Äôt managing stateful objects, but rather defining data structures and functions which just transform those structures in some way. This approach is a great fit for us, because we‚Äôre increasingly writing a lot of our business and even &lt;abbr title="user interface"&gt;UI&lt;/abbr&gt; logic in terms of &lt;a href="http://www.chriskrycho.com/2016/what-is-functional-programming.html#pure-functions"&gt;pure functions&lt;/a&gt; which transform simple ‚Äúrecord‚Äù types. That keeps each controller, route, component, or service doing relatively little work: they are responsible for getting and passing around data in the application, and for triggering actions‚Äîbut they‚Äôre not responsible for &lt;em&gt;understanding&lt;/em&gt; or &lt;em&gt;manipulating&lt;/em&gt; that data. Meanwhile the module code doesn‚Äôt do &lt;em&gt;any&lt;/em&gt; stateful work; there‚Äôs no mutation‚Äîjust boring, input-to-output functions.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; By contrast, if you‚Äôre dealing with stateful objects, you‚Äôre apt to end up running into places where you have lifecycle concerns, and that‚Äôs where Ember excels.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In summary:&lt;/strong&gt; in this model, Ember handles all the lifecycle and view management, and is responsible for sending data in and out of the application. Plain old modules handle defining what the core internal data types are, and for manipulating, transforming, and creating data.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you‚Äôre wondering: we‚Äôre not using anything like Redux or Immutable.js yet, but both &lt;a href="https://github.com/ember-redux/ember-redux"&gt;ember-redux&lt;/a&gt; and &lt;a href="https://github.com/rtfeldman/seamless-immutable"&gt;seamless-immutable&lt;/a&gt; would be great fits for the way we‚Äôre building the app at this point, and it‚Äôs likely at least &lt;a href="https://github.com/ember-redux/ember-redux"&gt;ember-redux&lt;/a&gt; will become part of our stack in the relatively near future.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 31 Jul 2017 19:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-31:/2017/typing-your-ember-part-4.html</guid><category>emberjs</category><category>typescript</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 3</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-3.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I‚Äôll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today‚Äîand I‚Äôll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. ‚Üí)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-1"&gt;first&lt;/a&gt; of this series, I described how to set up a brand new Ember.js app to use TypeScript. In the &lt;a href="/2017/typing-your-ember-part-2"&gt;second&lt;/a&gt; part, walked through adding TypeScript to an existing Ember.js app. In this part, I‚Äôm going to talk about using TypeScript effectively in a modern Ember.js app.&lt;/p&gt;
&lt;section id="heavy-lifting-so-so-results" class="level2"&gt;
&lt;h2&gt;Heavy lifting, so-so results&lt;/h2&gt;
&lt;p&gt;Let‚Äôs get this out of the way up front: right now, using types in anything which extends &lt;code&gt;Ember.Object&lt;/code&gt; is going to be a lot of work for a relatively low reward. &lt;code&gt;Ember.Object&lt;/code&gt; laid the foundation for the modern JavaScript class system (and thus the TypeScript class system), but it has a huge downside: it‚Äôs string keys and referennces all the way down. This kind of thing is just normal Ember code‚Äîand note all the string keys:&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default Component.extend({
  someProperty: &amp;#39;with a string value&amp;#39;,
  someOther: computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty = get(this, &amp;#39;someProperty&amp;#39;);
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What this comes out to‚Äîeven with a lot of the very helpful changes made to TypeScript itself in the 2.x series to help support object models like this one‚Äîis a lot of work adding types inline, and having to be really, really careful that your types are &lt;em&gt;correct&lt;/em&gt;. If that property you‚Äôre &lt;code&gt;Ember.get&lt;/code&gt;-ing can ever be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you‚Äôd better write the type as &lt;code&gt;string | void&lt;/code&gt; instead of just &lt;code&gt;string&lt;/code&gt;. For example: this code is written with the correct types:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default Component.extend({
  someProperty: &amp;#39;with a string value&amp;#39;,  // no type annotation
  someOther: computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty: string = get(this, &amp;#39;property&amp;#39;);
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note two important things about it, however:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;TypeScript does not (and, with the &lt;em&gt;current&lt;/em&gt; typings for Ember, cannot) figure out the type of &lt;code&gt;someProperty&lt;/code&gt; from this definition; &lt;code&gt;get&lt;/code&gt; currently just hands back &lt;code&gt;any&lt;/code&gt; as the type of these kinds of things. That type annotation is necessary for you to get any mileage out of TypeScript &lt;em&gt;at all&lt;/em&gt; in a computed property like this.&lt;/li&gt;
&lt;li&gt;If, anywhere in your code, you &lt;em&gt;set&lt;/em&gt; the value of &lt;code&gt;someProperty&lt;/code&gt;‚Äîincluding to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, or to &lt;code&gt;{ some: 'object' }&lt;/code&gt;‚Äîthis could fail.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Unfortunately, this second point means that TypeScript actually &lt;em&gt;can‚Äôt&lt;/em&gt; guarantee this the way we‚Äôd like. There‚Äôs hope coming for this in the future in several ways‚Äîmore on that in a moment‚Äîbut for now, I‚Äôll summarize this by saying TypeScript is really helpful &lt;em&gt;within&lt;/em&gt; a function, once you‚Äôve correctly defined the types you‚Äôre using. That means that you have to continue to be &lt;em&gt;very&lt;/em&gt; careful in what you‚Äôre doing in the context of any &lt;code&gt;Ember.Object&lt;/code&gt; instance, including all the Ember types which descend from &lt;code&gt;Object&lt;/code&gt;, and therefore also any types &lt;em&gt;you&lt;/em&gt; define which extend those in turn.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="future-niceties" class="level2"&gt;
&lt;h2&gt;Future niceties&lt;/h2&gt;
&lt;p&gt;In the future, we‚Äôll be able to get away from a lot of these difficulties by way of two changes coming down the line: Ember embracing ES6 classes to replace its current custom object system, and embracing decorators as a way of replacing the current approach to computed properties. Let‚Äôs take those in turn.&lt;/p&gt;
&lt;section id="class-syntax" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;class&lt;/code&gt; syntax&lt;/h3&gt;
&lt;p&gt;When Ember was birthed in the early 2010s (first as ‚ÄúSproutCore 2‚Äù and then ‚ÄúAmber.js‚Äù and finally ‚ÄúEmber.js‚Äù), the JavaScript world was a &lt;em&gt;remarkably&lt;/em&gt; different place. The current pace of change year to year is nothing short of astounding for any language, but doubly so for one that sat languishing for so long. When Ember came around, something like today‚Äôs &lt;code&gt;class&lt;/code&gt; syntax was unimaginable, and so essentially every framework had its own class system of some sort. Over the past few years, with the proposal and standardization of the &lt;code&gt;class&lt;/code&gt; syntax as nice sugar for JavaScript‚Äôs prototypal inheritance, the need for a custom object and inheritance model has essentially gone away entirely. However, Ember doesn‚Äôt do breaking changes to its API just because; we as a community and the core team in particular have chosen to place a high priority on backwards compatibility. So any adoption of ES6 classes had to work in such a way that we got it &lt;em&gt;without&lt;/em&gt; making everyone rewrite their code from scratch.&lt;/p&gt;
&lt;p&gt;All of this impacts our story with TypeScript because, well, TypeScript for a long time couldn‚Äôt even begin to handle this kind of complexity (it‚Äôs a lot for a static type system to be able to express, given how &lt;em&gt;very&lt;/em&gt; dynamic the types here can be). As of TS 2.3, it can express &lt;em&gt;most&lt;/em&gt; of this object model, which is great‚Ä¶ but it‚Äôs forever out of step with the rest of the JS/TS ecosystem, which is not so great. ES6 classes are first-class items in TypeScript and the support for getting types right within them is much, &lt;em&gt;much&lt;/em&gt; stronger than the support for the mixin/extension style object model Ember currently uses. So moving over to ES6 classes will make it much easier for TS to do the work of telling you &lt;em&gt;you‚Äôre doing it wrong with that class&lt;/em&gt;‚Äîand most importantly, it‚Äôll be able to do that automatically, without needing the incredibly hairy type definition files that we‚Äôre still trying to write to get Ember‚Äôs current model represented. It Will Just Work. That means less maintenance work and fewer places for bugs to creep in.&lt;/p&gt;
&lt;p&gt;Gladly, we‚Äôre getting there! Already today, in the most recent versions of Ember, you can write this, and it will work:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;

export default class MyComponent extends Component {
  theAnswer = 42;
  andTheQuestionIs =
    &amp;quot;What is the meaning of life, the universe, and everything?&amp;quot;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When I say ‚Äúit will work,‚Äù I mean you can then turn around and write this in your &lt;code&gt;my-component.hbs&lt;/code&gt; and it‚Äôll be exactly what you would expect from the old &lt;code&gt;Ember.Component.extend()&lt;/code&gt; approach:&lt;/p&gt;
&lt;pre class="hbs"&gt;&lt;code&gt;{{andTheQuestionIs}} {{the Answer}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is one serious limitation of that today: you can‚Äôt do that with a class you need to extend &lt;em&gt;further&lt;/em&gt;. So if, for example, you do like we do and customize the application route rinstance and then reuse that in a couple places, you‚Äôll still have to use the old syntax:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Route from &amp;#39;@ember/route&amp;#39;;

export default Route.extend({
  // your customizations...
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But everywhere you consume that, you can use the new declaration:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import ApplicationRoute from &amp;#39;my-app/routes/application&amp;#39;;

export default class JustSomeRoute extends ApplicationRoute {
  model() {
    // etc.
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There‚Äôs more work afoot here, too, to make it so that these restrictions can go away entirely‚Ä¶ but those changes will undoubtedly be covered in considerable detail on &lt;a href="http://www.emberjs.com/blog/"&gt;the official Ember blog&lt;/a&gt; when they roll out.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="decorators" class="level3"&gt;
&lt;h3&gt;Decorators&lt;/h3&gt;
&lt;p&gt;Now, that‚Äôs all well and good, but it doesn‚Äôt necessarily help with this scenario:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;is just a string&amp;#39;;

  someOtherProperty = computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty = get(this, &amp;#39;someProperty&amp;#39;);
    return someProperty + &amp;#39; and now I have appended to it&amp;#39;;
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We‚Äôre back in the same spot of having unreliable types there. And again: some really careful work writing type definitions to make sure that &lt;code&gt;computed&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; both play nicely together with the class definition would help somewhat, but‚Ä¶ well, it‚Äôd be nice if the types could just be determined automatically by TypeScript. (Also, there‚Äôs an &lt;a href="https://github.com/Microsoft/TypeScript/issues/16699"&gt;open bug&lt;/a&gt; on the TypeScript repository for trying to deal with &lt;code&gt;computed&lt;/code&gt;; suffice it to say that computed as it currently stands is a sufficiently complicated thing that even with all the incredible type machinery TS 2.1, 2.2, and 2.3 have brought to bear on exactly these kinds of problems‚Ä¶ it still can‚Äôt actually model &lt;code&gt;computed&lt;/code&gt; correctly.)&lt;/p&gt;
&lt;p&gt;For several years now, Rob Jackson has maintained [a small library] that let you write computed properties with decorators. Up till recently, those were incompatible with TypeScript, because they used to work in the context of object literals rather than classes‚Äîand TypeScript never supported that. However, as of about a month ago as I‚Äôm writing this, they‚Äôve been updated and they &lt;em&gt;do&lt;/em&gt; work with ES6 classes. So, given the class syntax discussed above, you can now &lt;code&gt;ember install ember-decorators&lt;/code&gt; and then do this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed } from &amp;#39;ember-decorators/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;with a string value&amp;#39;;

  @computed(&amp;#39;someProperty&amp;#39;)
  someOther(someProperty: string) {
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we can provide a type on the parameter to &lt;code&gt;someOther&lt;/code&gt;, which at a minimum makes this enormously cleaner and less repetitive syntactically. More interestingly, however, we &lt;em&gt;should&lt;/em&gt; (though no one has done it just yet, to my knowledge) be able to write a type definition for &lt;code&gt;@computed&lt;/code&gt; such that TypeScript will already know that &lt;code&gt;someProperty&lt;/code&gt; here &lt;em&gt;is&lt;/em&gt; a string, because it‚Äôll have the context of the class in which it‚Äôs operating. So that example will be even simpler:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed } from &amp;#39;ember-decorators/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;with a string value&amp;#39;;

  @computed(&amp;#39;someProperty&amp;#39;)
  someOther(someProperty) {
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in that imagined, wonderful future world, if we tried to do something that isn‚Äôt a valid string operation‚Äîsay, we tried &lt;code&gt;someProperty / 3&lt;/code&gt;‚ÄîTypeScript would complain to us, loudly.&lt;/p&gt;
&lt;p&gt;Although this is still a future plan, rather than a present reality, it‚Äôs not &lt;em&gt;that&lt;/em&gt; far off. We just need someone to write that type definition for the decorators, and we‚Äôll be off to the races wherever we‚Äôre using the new ES6 class approach instead of the existing &lt;code&gt;Ember.Object&lt;/code&gt; approach. So: &lt;em&gt;soon&lt;/em&gt;. I don‚Äôt know how soon, but soon.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="current-ameliorations" class="level2"&gt;
&lt;h2&gt;Current ameliorations&lt;/h2&gt;
&lt;p&gt;In the meantime, of course, many of us are maintaining large codebases. I just checked, and our app (between the app itself and the tests) has around 850 files and 34,000 lines of code. Even as those new abilities land, we‚Äôre not going to be converting all of them all at once. And we want to get some real mileage out of TypeScript in the meantime. One of the best ways I‚Äôve found to do this is to take a step back and think about the pieces of the puzzle which Ember is solving for you, and which it &lt;em&gt;isn‚Äôt&lt;/em&gt;. That is, Ember is really concerned with managing application state and lifecycle, and with rendering the UI. And it‚Äôs &lt;em&gt;fabulous&lt;/em&gt; about those things. What it‚Äôs not particularly concerned with (and what it shouldn‚Äôt be) is the particulars of how your business logic is implemented. And there‚Äôs no particular reason, &lt;em&gt;especially&lt;/em&gt; if most of that business logic is implemented in terms of a bunch of pure, straightforward, input-to-output functions that operate on well-defined data types, for all of your business logic to live in &lt;code&gt;Ember.Object&lt;/code&gt;-descended classes.&lt;/p&gt;
&lt;p&gt;Instead, we have increasingly chosen to write our business logic in bog-standard TypeScript files. These days, our app has a &lt;code&gt;lib&lt;/code&gt; directory in it, with packages like &lt;code&gt;utilities&lt;/code&gt; for commonly used tools‚Ä¶ but also like &lt;code&gt;billing&lt;/code&gt;, where we implement &lt;em&gt;all&lt;/em&gt; of our client-side billing business logic. The display logic goes in the &lt;code&gt;Ember.Controller&lt;/code&gt; and &lt;code&gt;Ember.Component&lt;/code&gt; classes, and the routing and state management goes in the &lt;code&gt;Ember.Route&lt;/code&gt; and &lt;code&gt;Ember.Data&lt;/code&gt; pieces as you‚Äôd expect. But none of the business logic lives there. That means that we‚Äôre entirely free of the aforementioned constraints for the majority of the time dealing with that data. If we do a good job making sure the data is good at the boundaries‚Äîroute loads, for example, and when we send it back to the server‚Äîthen we can effectively treat everything else as just boring old (new?) TypeScript.&lt;/p&gt;
&lt;p&gt;So far we‚Äôve only taken that approach with about a quarter of our app, but it‚Äôs all the latest pieces of our app, and it has been incredibly effective. Even once we‚Äôre able to take advantage of all those shiny new features, we‚Äôre going to keep leaning heavily on this approach, because it lets Ember do what Ember is best at, and keeps us from coupling our business logic to the application state management or view rendering details.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that‚Äôs the state of things in Ember with TypeScript today. Your best bet for getting real mileage out of TypeScript today is to use the new class syntax support and decorators wherever you can within Ember-specific code, and then to write as much of your business logic outside the Ember system as possible. Gladly, all of that points you right at the future (in the case of syntax) and just good practice (in the case of separating out your business logic). So: not too shabby overall. It‚Äôs working well for us, and I hope it does for you as well!&lt;/p&gt;
&lt;p&gt;Next time: how we got here with the &lt;code&gt;ember-cli-typescript&lt;/code&gt; compiler, and where we hope to go from here!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note that here and throughout, I‚Äôm using the &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#addendum-1---table-of-module-names-and-exports-by-global"&gt;RFC #176 Module API&lt;/a&gt;, which you can use today via &lt;a href="https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill"&gt;this polyfill&lt;/a&gt;.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 28 Jul 2017 12:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-28:/2017/typing-your-ember-part-3.html</guid><category>emberjs</category><category>typescript</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 2</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-2.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I‚Äôll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today‚Äîand I‚Äôll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. ‚Üí)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-1"&gt;first part&lt;/a&gt; of this series, I described how to set up a brand new Ember.js app to use TypeScript. In this part, I‚Äôm going to talk about starting to use TypeScript in the context of an existing Ember.js app.&lt;/p&gt;
&lt;p&gt;This is, in many ways, even simpler than setting up an app for the first time, because you already have almost everything you need. The steps here are exactly what you‚Äôre used to if you‚Äôre used to using the Ember CLI ecosystem:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;ember-cli-typescript&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Start using TypeScript wherever you want in your app.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It really is that simple, for the most part. There are a couple qualifications, and a couple tips, though.&lt;/p&gt;
&lt;p&gt;Let‚Äôs start with &lt;strong&gt;qualifications&lt;/strong&gt;. There are open, unresolved &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/"&gt;issues&lt;/a&gt; about using &lt;code&gt;ember-cli-typescript&lt;/code&gt; in your app in certain contexts. For example: &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/8"&gt;using it with &lt;code&gt;ember-browserify&lt;/code&gt;&lt;/a&gt;. While everything will &lt;em&gt;build&lt;/em&gt; correctly in that case (even if the TypeScript compiler complains about being unable to resolve some things, the Ember CLI build pipeline will still work as expected), your editor integration won‚Äôt. There are a bunch of corners like this we‚Äôre still hammering out; those are the main things we need to get resolved before we can call this a ‚Äú1.0.‚Äù We have the &lt;em&gt;main&lt;/em&gt; stuff working, but, well‚Ä¶ there‚Äôs more to do.&lt;/p&gt;
&lt;p&gt;Along those same lines, you should take a close look at the &lt;a href="https://github.com/emberwatch/ember-cli-typescript#not-yet-supported"&gt;&lt;strong&gt;Not yet supported&lt;/strong&gt;&lt;/a&gt; section of the README. There are parts of Ember‚Äôs programming model which TypeScript certainly &lt;em&gt;can&lt;/em&gt; support, but which we haven‚Äôt done the lifting to get the type declaration file to help with yet. (Looking for a place to pitch in and already comfortable doing some heavy lifting with some of TypeScript‚Äôs &lt;a href="http://www.typescriptlang.org/docs/handbook/mixins.html"&gt;most advanced type features&lt;/a&gt;? We could use the help.)&lt;/p&gt;
&lt;p&gt;One other thing to be aware of is that your &lt;code&gt;tsconfig.json&lt;/code&gt; settings will affect what kind of resolution your editor gives you. If you have &lt;code&gt;allowJs&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;, your editors will resolve JS modules. Otherwise, they‚Äôll &lt;em&gt;only&lt;/em&gt; resolve TS modules. This can be incredibly annoying at times. However, this isn‚Äôt something we‚Äôve nailed down in terms of what the default should be yet. (You can &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/"&gt;come tell us&lt;/a&gt; on GitHub if you have thoughts or insights there!) And the fact that Microsoft has left this configurable is suggestive: different projects may have different preferences here.&lt;/p&gt;
&lt;p&gt;Now, for the &lt;strong&gt;tips&lt;/strong&gt;. Note that these are just a couple quick pointers; I‚Äôll come back and talk about structuring your project and more sophisticated uses of TypeScript in the future.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Don‚Äôt turn on &lt;code&gt;--strict&lt;/code&gt; or the corresponding individual flags on day 1. Unless you have an extremely unusual and disciplined Ember.js codebase, you‚Äôll have an incredible set of errors to deal with.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don‚Äôt set the the &lt;code&gt;noEmitOnError&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;, for much the same reason. Since the state of type declaration files for Ember is best described as &lt;em&gt;nascent&lt;/em&gt; at present, many of your files will have errors in them just from failed imports!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don‚Äôt try to convert everything at once. Just pick the next feature or bug you‚Äôre working on, and start with the files you‚Äôre touching for that bug. Rename it to &lt;code&gt;.ts&lt;/code&gt;, fix any major issues it flags up that you can‚Äîbut stick as locally as possible. You‚Äôre apt to find a &lt;em&gt;lot&lt;/em&gt; of small bugs as you start migrating, and some of them are things which are apt to affect your whole system because they touch central data types. It‚Äôs okay. You can come back to those later. For today, you can just be explicit about the weirdnesses.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As part of that: get comfortable‚Äîreally, really comfortable‚Äîwith &lt;a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt;. They‚Äôll make it much easier to express the kind of code you‚Äôve &lt;em&gt;actually&lt;/em&gt; written.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don‚Äôt worry about adding explicit types to &lt;em&gt;everything.&lt;/em&gt; In fact, depending on how comfortable you are already with typed languages, you should probably take a pretty different tack with this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you‚Äôre just stepping into the world of typed programming languages, you might start adding types where they‚Äôre the &lt;em&gt;lowest risk&lt;/em&gt;: some place like your automated tests. That‚Äôll help you start to see how to take advantage of them, while not impacting the way you write your app code until you have a better idea how best to employ the types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you‚Äôre already really comfortable with typed programming languages, you might employ types where they‚Äôre &lt;em&gt;most helpful:&lt;/em&gt; start with some types in the hairiest or trickiest spots of your app.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is plenty more I could say, but I think that‚Äôs a good start for now. I‚Äôll have lots more to add in later posts about the details of how specifically to get the most mileage out of types within an Ember.js app today.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2017/typing-your-ember-part-1"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Part 1 ‚Äì Set your Ember.js project up to use TypeScript.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Also, I &lt;em&gt;strongly&lt;/em&gt; encourage you to write types in terms of unions of types rather than in terms of &lt;a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties"&gt;optional properties on types&lt;/a&gt;. That might be surprising; I‚Äôll explain it in more detail in a future post.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 07 May 2017 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-07:/2017/typing-your-ember-part-2.html</guid><category>typescript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 1</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-1.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I‚Äôll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today‚Äîand I‚Äôll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. ‚Üí)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In this first post in the series, we‚Äôre going to keep things simple and easy: we‚Äôre going to get an Ember.js app configured to use TypeScript. Later posts will cover some of the other details.&lt;/p&gt;
&lt;p&gt;Because of the lovely &lt;a href="https://ember-cli.com"&gt;Ember CLI&lt;/a&gt; ecosystem, this is a pretty straightforward process. I‚Äôm going to start from &lt;em&gt;zero&lt;/em&gt; so that even if you‚Äôve never written an Ember app before, you can get this up and running by following these instructions. These instructions have also been tested and confirmed to work across platforms‚Äîyou can do this equally on Windows, macOS, or Linux.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Make sure you have Ember‚Äôs prerequisites installed. Get &lt;a href="https://nodejs.org/en/"&gt;Node&lt;/a&gt; for your platform. Optionally (but highly recommended) install &lt;a href="https://yarnpkg.com"&gt;Yarn&lt;/a&gt; to manage your Node packages.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the Ember command lines tools globally:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;yarn global add ember-cli&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;npm install --global ember-cli&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create an Ember app.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember new my-ts-app --yarn&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Using the &lt;code&gt;--yarn&lt;/code&gt; flag will make it so your app uses &lt;a href="https://yarnpkg.com"&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/a&gt; and creates a &lt;code&gt;yarn.lock&lt;/code&gt; file instead of using &lt;code&gt;npm&lt;/code&gt; when it installs its dependencies.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now move to the root of the newly created app: this is where we‚Äôll do everything else in the post.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cd my-ts-app&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;a href="https://emberobserver.com/addons/ember-cli-typescript"&gt;&lt;em&gt;ember-cli-typescript&lt;/em&gt; add-on&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generate your first UI component.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember generate component some-input&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Rename the files it generated from &lt;code&gt;.js&lt;/code&gt; to &lt;code&gt;.ts&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;app/components/some-input.js&lt;/code&gt; ‚Üí &lt;code&gt;app/components/some-input.ts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tests/integration/components/some-input-test.js&lt;/code&gt; ‚Üí &lt;code&gt;tests/integration/components/some-input-test.ts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Eventually, we‚Äôll make it so that you get TypeScript for all newly generated components when using &lt;em&gt;ember-cli-typescript&lt;/em&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add some content to the files:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;{{!-- some-input.hbs --}}
{{input value=theValue change=(mut theValue)}}
{{theValue}}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// some-input.ts
import Ember from &amp;#39;ember&amp;#39;;

export default Ember.Component.extend({
  theValue: &amp;#39;&amp;#39;,
});&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update your &lt;code&gt;application.hbs&lt;/code&gt; file to remove the default &lt;code&gt;{{welcome}}&lt;/code&gt; template and replace it with &lt;code&gt;{{some-input}}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Spin up the Ember application with Ember CLI‚Äôs development server:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember serve&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You‚Äôll likely note some warnings: the TypeScript compiler won‚Äôt be able to find some of the modules imported in your files. I‚Äôll have more to say about this in a future post. For now, suffice it to say: don‚Äôt worry, Ember CLI is still resolving and compiling your modules just fine.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Load the application by going to &lt;code&gt;localhost:4200&lt;/code&gt; in your browser. You should see a blank white screen with an input in it. Type in it, and see the input rendered to the page. Simple enough, but it‚Äôs using a TypeScript file compiled along the way!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that‚Äôs it: we‚Äôre done setting up an Ember.js app to use TypeScript! In the next post, I‚Äôll talk a bit about strategies for migrating an existing app to TypeScript‚Äînot just the mechanics of it, but also where and how to start actually integrating types into your code.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2017/typing-your-ember-part-2"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Part 2 ‚Äì Adding TypeScript to an existing Ember.js project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I strongly prefer to use &lt;code&gt;yarn&lt;/code&gt; over &lt;code&gt;npm&lt;/code&gt; because &lt;code&gt;yarn&lt;/code&gt; installs are predictable and repeatable, and if there‚Äôs one thing I don‚Äôt need to spend time on when developing our Ember.js app at Olo, it‚Äôs chasing problems with transitive dependencies that are different in the build server than in my local development environment. Yarn‚Äôs lockfiles mean what ends up built on the server is &lt;em&gt;exactly&lt;/em&gt; what ended up built on my machine.&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;But if you‚Äôre curious, here‚Äôs a preview: we really need more &lt;a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html"&gt;type definitions&lt;/a&gt; for the Ember ecosystem. I‚Äôll be covering &lt;em&gt;how&lt;/em&gt; we build those in much more detail in a future installment.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 05 May 2017 00:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-05:/2017/typing-your-ember-part-1.html</guid><category>typescript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we‚Äôre both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I‚Äôll be reusing some of this material as the basis of an internal tech talk I‚Äôm giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs not tied to JS directly, which means it‚Äôs free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That‚Äôs the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it‚Äôs‚Ä¶ still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm‚Äôs type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript‚Äôs is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; ‚Äì not mostly sure, 100% sure ‚Äì that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say ‚Äúby design,‚Äù I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of ‚Äúsoundness holes‚Äù in the type system‚Äîthere‚Äôs still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS‚Ä¶ but not none. (That‚Äôs even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It‚Äôs just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm‚Äôs language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean‚Äî&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that‚Äôs no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I‚Äôd summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title>TypeScript keyof Follow-Up</title><link>http://www.chriskrycho.com/2017/typescript-keyof-follow-up.html</link><description>&lt;p&gt;I recently wrote up some neat things you can do with &lt;a href="http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html"&gt;&lt;code&gt;keyof&lt;/code&gt; and mapped types&lt;/a&gt; in TypeScript 2.1. In playing further with those bits, I ran into some interesting variations on the approach I outlined there, so here we are.&lt;/p&gt;
&lt;p&gt;In the previous post, I concluded with an example that looked like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};

type State
  = &amp;#39;Pending&amp;#39;
  | &amp;#39;Started&amp;#39;
  | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;code&gt;UnionKeyToValue&amp;lt;State&amp;gt;&lt;/code&gt; type constraint requires us to fill out the &lt;code&gt;STATE&lt;/code&gt; object as expected. The whole point of this exercise was to give us the benefit of code completion with that STATE type so we could use it and not be worried about the kinds of typos that too-often bite us with stringly-typed arguments in JavaScript.&lt;/p&gt;
&lt;p&gt;It turns out we don‚Äôt &lt;em&gt;need&lt;/em&gt; that to get completion, though. All editors which use the TypeScript language service will give us the same degree of completion if we start typing a string and then trigger completion:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://cdn.chriskrycho.com/images/more-ts.gif" title="screen capture of string completion in VS Code" alt="string completion with TypeScript 2.1" /&gt;&lt;figcaption&gt;string completion with TypeScript 2.1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Granted that you have to know this is a string (though the JetBrains &lt;abbr title="integrated development environment"&gt;IDE&lt;/abbr&gt;s will actually go a step further and suggest the right thing &lt;em&gt;without&lt;/em&gt; needing the string key). But that‚Äôs roughly equivalent to knowing you need to import the object literal constant to get the completion that way. Six one, half dozen the other, I think.&lt;/p&gt;
&lt;p&gt;This makes it something of a wash with the original approach, as long as you‚Äôre dealing in a pure-TypeScript environment. The big advantage that the original approach still has, of course, is that it also plays nicely with a mixed TypeScript and JavaScript environment. If you‚Äôre just progressively adding TypeScript to an existing JavaScript codebase, that‚Äôs possibly reason enough to stick with it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: an additional reason to prefer my original solution:&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="en"&gt;
&lt;p lang="en" dir="ltr"&gt;
&lt;a href="https://twitter.com/chriskrycho"&gt;@chriskrycho&lt;/a&gt; &lt;a href="https://twitter.com/typescriptlang"&gt;@typescriptlang&lt;/a&gt; I think a benefit of your previous solution is that you can rename keys and all their usages.
&lt;/p&gt;
‚Äî Timm (@timmpreetz) &lt;a href="https://twitter.com/timmpreetz/status/816672215924097024"&gt;January 4, 2017&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 03 Jan 2017 20:35:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-01-03:/2017/typescript-keyof-follow-up.html</guid><category>programming languages</category><category>software development</category><category>typescript</category><category>javascript</category></item><item><title>keyof and Mapped Types In TypeScript 2.1</title><link>http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html</link><description>&lt;p&gt;In the last few months, I‚Äôve been playing with both &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt; and &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; as tools for increasing the quality and reliability of the JavaScript I write at Olo. Both of these are syntax that sits on top of normal JavaScript to add type analysis‚Äîbasically, a form of &lt;a href="https://en.wikipedia.org/wiki/Gradual_typing"&gt;gradual typing&lt;/a&gt; for JS.&lt;/p&gt;
&lt;p&gt;Although TypeScript‚Äôs tooling has been better all along&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I initially preferred Flow‚Äôs type system quite a bit: it has historically been much more focused on &lt;a href="http://stackoverflow.com/questions/21437015/soundness-and-completeness-of-systems"&gt;soundness&lt;/a&gt;, especially around the &lt;em&gt;many&lt;/em&gt; problems caused by &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, than TypeScript. And it had earlier support for &lt;a href="https://flowtype.org/docs/disjoint-unions.html"&gt;tagged unions&lt;/a&gt;, a tool I‚Äôve come to find invaluable since picking them up from my time with Rust.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But the 2.0 and 2.1 releases of TypeScript have changed the game substantially, and it‚Äôs now a &lt;em&gt;very&lt;/em&gt; compelling language in its own right‚Äînot to mention a great tool for writing better JavaScript. So I thought I‚Äôd highlight how you can get a lot of the benefits you would get from the type systems of languages like Elm with some of those new TypeScript features: the &lt;em&gt;&lt;code&gt;keyof&lt;/code&gt; operator&lt;/em&gt; and &lt;em&gt;mapped types&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i&gt;Some readers may note that what I‚Äôm doing here is a &lt;em&gt;lot&lt;/em&gt; of wrangling to cajole TypeScript into giving me the kinds of things you get for free in an ML-descended language. Yep. The point is that you &lt;em&gt;can&lt;/em&gt; wrangle it into doing this.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="plain-old-javascript" class="level3"&gt;
&lt;h3&gt;Plain old JavaScript&lt;/h3&gt;
&lt;p&gt;Let‚Äôs say we want to write a little state machine in terms of a function to go from one state to the next, like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case &amp;#39;Pending&amp;#39;: return &amp;#39;Started&amp;#39;;
    case &amp;#39;Started&amp;#39;: return &amp;#39;Completed&amp;#39;;
    case &amp;#39;Completed&amp;#39;: return &amp;#39;Completed&amp;#39;;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will work, and it‚Äôll even throw an error if you hand it the wrong thing. But you‚Äôll find out at runtime if you accidentally typed &lt;code&gt;nextState('Pednign')&lt;/code&gt; instead of &lt;code&gt;nextState('Pending')&lt;/code&gt;‚Äîsomething I‚Äôve done more than once in the past. You‚Äôd have a similar problem if you‚Äôd accidentally written &lt;code&gt;case 'Strated'&lt;/code&gt; instead of &lt;code&gt;case 'Started'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many contexts like this one in JavaScript‚Äîperhaps the most obvious being &lt;a href="http://redux.js.org/docs/basics/Actions.html"&gt;Redux actions&lt;/a&gt;, but I get a lot of mileage out of the pattern in Ember, as well. In these contexts, I find it‚Äôs convenient to define types that are kind of like pseudo-enums or pseudo-simple-unions, like so:&lt;a href="#fn3" class="footnoteRef" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you‚Äôve defined an object this way, instead of using strings directly in functions that take it as an argument, like &lt;code&gt;nextState('Started')&lt;/code&gt;, you can use the object property: &lt;code&gt;nextState(STATE.Started)&lt;/code&gt;. You can rewrite the function body to use the object definition instead as well:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case STATE.Pending: return STATE.Started;
    case STATE.Started: return STATE.Completed;
    case STATE.Completed: return STATE.Completed;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the object and its keys instead gets you something like a namespaced constant. As a result, you can get more help with things like code completion from your editor, along with warnings or errors from your linter if you make a typo. You‚Äôll also get &lt;em&gt;slightly&lt;/em&gt; more meaningful error messages if you type the wrong thing. For example, if you type &lt;code&gt;STATE.Strated&lt;/code&gt; instead of &lt;code&gt;STATE.Started&lt;/code&gt;, any good editor will give you an error‚Äîespecially if you‚Äôre using a linter. At Olo, we use &lt;a href="http://eslint.org"&gt;ESLint&lt;/a&gt;, and we have it &lt;a href="https://github.com/ember-cli/ember-cli-eslint/"&gt;set up&lt;/a&gt; so that this kind of typo/linter error fails our test suite (and we never merge changes that don‚Äôt pass our test suite!).&lt;/p&gt;
&lt;p&gt;This is about as good a setup as you can get in plain-old JavaScript. As long as you‚Äôre disciplined and always use the object, you get some real benefits from using this pattern. But you &lt;em&gt;always&lt;/em&gt; have to be disciplined. If someone who is unfamiliar with this pattern types &lt;code&gt;nextState('whifflebats')&lt;/code&gt; somewhere, well, we‚Äôre back to blowing up at runtime. Hopefully your test suite catches that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="typescript-to-the-rescue" class="level3"&gt;
&lt;h3&gt;TypeScript to the rescue&lt;/h3&gt;
&lt;p&gt;TypeScript gives us the ability to &lt;em&gt;guarantee&lt;/em&gt; that the contract is met (that we‚Äôre not passing the wrong value in). As of the latest release, it also lets us guarantee the &lt;code&gt;STATES&lt;/code&gt; object to be set up the way we expect. And last but not least, we get some actual productivity boosts when writing the code, not just when debugging it.&lt;/p&gt;
&lt;p&gt;Let‚Äôs say we decided to constrain our &lt;code&gt;nextState&lt;/code&gt; function so that it had to both take and return some kind of &lt;code&gt;State&lt;/code&gt;, representing one of the states we defined above. We‚Äôll leave a &lt;code&gt;TODO&lt;/code&gt; here indicating that we need to figure out how to write the type of &lt;code&gt;State&lt;/code&gt;, but the function definition would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// TODO: figure out how to define `State`
function nextState(state: State): State {
  // the same body...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript has had &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt; since the &lt;a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html"&gt;1.4 release&lt;/a&gt; so they might seem like an obvious choice, and indeed we could write easily a type definition for the strings in &lt;code&gt;STATES&lt;/code&gt; as a union:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, you can‚Äôt write something like &lt;code&gt;State.Pending&lt;/code&gt; somewhere; you have to write the plain string &lt;code&gt;'Pending'&lt;/code&gt; instead. You still get some of the linting benefits you got with the approach outlined above via TypeScript‚Äôs actual type-checking, but you don‚Äôt get &lt;em&gt;any&lt;/em&gt; help with autocompletion. Can we get the benefits of both?&lt;/p&gt;
&lt;p&gt;Yes! (This would be a weird blog post if I just got this far and said, ‚ÄúNope, sucks to be us; go use Elm instead.‚Äù)&lt;/p&gt;
&lt;p&gt;As of the 2.1 release, TypeScript lets you define types in terms of keys, so you can write a type like this:&lt;a href="#fn4" class="footnoteRef" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can use that type any place you need to constrain the type of a variable, or a return, or whatever:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const goodState: StateFromKeys = STATE.Pending;

// error: type &amp;#39;&amp;quot;Blah&amp;quot;&amp;#39; is not assignable to type &amp;#39;State&amp;#39;
const badState: StateFromKeys = &amp;#39;Blah&amp;#39;;

interface StateMachine {
  (state: StateFromKeys): StateFromKeys;
}

const nextState: StateMachine = (state) =&amp;gt; {
  // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The upside to this is that now you can guarantee that anywhere you‚Äôre supposed to be passing one of those strings, you &lt;em&gt;are&lt;/em&gt; passing one of those strings. If you pass in &lt;code&gt;'Compelte'&lt;/code&gt;, you‚Äôll get an actual error‚Äîjust like if we had used the union definition above. At a minimum, that will be helpful feedback in your editor. Maximally, depending on how you have your project configured, it may not even generate any JavaScript output.&lt;a href="#fn5" class="footnoteRef" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; So that‚Äôs a significant step forward beyond what we had even with the best linting rules in pure JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="going-in-circles" class="level3"&gt;
&lt;h3&gt;Going in circles&lt;/h3&gt;
&lt;p&gt;But wait, we can do more! TypeScript 2.1 &lt;em&gt;also&lt;/em&gt; came with a neat ability to define ‚Äúmapped types,‚Äù which map one object type to another. They have a few &lt;a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types"&gt;interesting examples&lt;/a&gt; which are worth reading. What‚Äôs interesting to us here is that you can write a type like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in keyof typeof STATE]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, you can simplify that using the type we defined above, since &lt;code&gt;StateFromKeys&lt;/code&gt; was just &lt;code&gt;keyof typeof STATE&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We‚Äôve now defined an object type whose &lt;em&gt;key&lt;/em&gt; has to be one of the items in the &lt;code&gt;State&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Now, by itself, this isn‚Äôt all that useful. Above, we defined that as the keys on the &lt;code&gt;STATE&lt;/code&gt; object, but if we tried to use that in conjunction with this new type definition, we‚Äôd just end up with a recursive type definition: &lt;code&gt;StateFromKeys&lt;/code&gt; defined as the keys of &lt;code&gt;STATE&lt;/code&gt;, &lt;code&gt;StateAsMap&lt;/code&gt; defined in terms of the elements of &lt;code&gt;StateFromKeys&lt;/code&gt;, and then &lt;code&gt;STATE&lt;/code&gt; defined as a &lt;code&gt;StateAsMap&lt;/code&gt;‚Ä¶&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: StateAsMap = {
  Pending: &amp;#39;Pending&amp;#39;,
  Active: &amp;#39;Active&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}

type StateFromKeys = keyof typeof STATE;

type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You end up with multiple compiler errors here, because of the circular references. This approach won‚Äôt work. If we take a step back, though, we can work through this (and actually end up someplace better).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="join-forces" class="level3"&gt;
&lt;h3&gt;Join forces!&lt;/h3&gt;
&lt;p&gt;First, let‚Äôs start by defining the mapping generically. After all, the idea here was to be able to use this concept all over the place‚Äîe.g.¬†for &lt;em&gt;any&lt;/em&gt; Redux action, not just one specific one. We don‚Äôt need this particular &lt;code&gt;State&lt;/code&gt;; we just need a constrained set of strings (or numbers) to be used as the key of an object:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type MapKeyAsValue&amp;lt;Key extends string&amp;gt; = {
  [K in Key]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In principle, if we didn‚Äôt have to worry about the circular references, we could use that to constrain our definition of the original &lt;code&gt;STATE&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: MapKeyAsValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how to get around the problem of circular type definitions? Well, it turns out that the &lt;code&gt;K&lt;/code&gt; values in these &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; and &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; types are equivalent:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// Approach 1, using an object
const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;
type StateObjectKeyToValue = {
  [K in StateFromKeys]: K  // &amp;lt;- K is just the keys!
};

// Approach 2, using unions
type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;
type StateUnionKeyToValue = {
  [K in StateUnion]: K  // &amp;lt;- K is also just the keys!
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, unlike the &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; version, &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; doesn‚Äôt make any reference to the &lt;code&gt;STATE&lt;/code&gt; object. So we can use &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; to constrain &lt;code&gt;STATE&lt;/code&gt;, and then just use &lt;code&gt;StateUnion&lt;/code&gt; to constrain all the places we want to &lt;em&gt;use&lt;/em&gt; one of those states. Once we put it all together, that would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

type StateUnionKeyToValue = {
  [K in StateUnion]: K
};

const STATE: StateUnionKeyToValue = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By doing this, we get two benefits. First, &lt;code&gt;STATE&lt;/code&gt; now has to supply the key and value for &lt;em&gt;all&lt;/em&gt; the union‚Äôs variants. Second, we know that the key and value are the same, and that they map to the union‚Äôs variants. These two facts mean that we can be 100% sure that wherever we define something as requiring a &lt;code&gt;State&lt;/code&gt;, we can supply one of the items on &lt;code&gt;STATE&lt;/code&gt; and it will be guaranteed to be correct. If we change the &lt;code&gt;State&lt;/code&gt; union definition, everything else will need to be updated, too.&lt;/p&gt;
&lt;p&gt;Now we can make this generic, so it works for types besides just this one set of states‚Äîso that it‚Äôll work for &lt;em&gt;any&lt;/em&gt; union type with string keys, in fact. (That string-key constraint is important because objects in TypeScript can currently only use strings or numbers as keys; whereas union types can be all sorts of things.) Apart from that constraint on the union, though, we can basically just substitute a generic type parameter &lt;code&gt;U&lt;/code&gt;, for ‚Äúunion,‚Äù where we had &lt;code&gt;StateUnion&lt;/code&gt; before.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then any object we say conforms to this type will take a union as its type parameter, and every key on the object must have exactly the same value as the key name:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If any of those don‚Äôt have &lt;em&gt;exactly&lt;/em&gt; the same value as the key name, you‚Äôll get an error. So, each of the following value assignments would fail to compile, albeit for different reasons (top to bottom: capitalization, misspelling, and missing a letter).&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const BAD_STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;pending&amp;#39;,  // look ma, no capitals
  Started: &amp;#39;Strated&amp;#39;,  // St-rated = whuh?
  Completed: &amp;#39;Complete&amp;#39;,  // so tense
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You‚Äôll see a compiler error that looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div style="white-space: pre-line;"&gt;[ts]
Type ‚Äò{ Pending: ‚Äúpending‚Äù; Started: ‚ÄúStrated‚Äù; Completed: ‚ÄúComplete‚Äù }‚Äô is not assignable to type ‚ÄòUnionKeyToValue&lt;State&gt;‚Äô.
¬†¬†Types of property ‚ÄòPending‚Äô are incompatible.
¬†¬†¬†¬†Type ‚Äò‚Äúpending‚Äù‚Äô is not assignable to type ‚Äò‚ÄúPending‚Äù‚Äô.&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the key and the name don‚Äôt match, the compiler tells us we didn‚Äôt keep the constraint we defined on what these types should look like. Similarly, if you forget an item from the union, you‚Äôll get an error. If you add an item that isn‚Äôt in the original union, you‚Äôll get an error. Among other things, this means that you can be confident that if you add a value to the union, the rest of your code won‚Äôt compile until you include cases for it. You get all the power and utility of using union types, &lt;em&gt;and&lt;/em&gt; you get the utility of being able to use the object as a namespace of sorts.&lt;a href="#fn6" class="footnoteRef" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the TypeScript language service‚Äîwhich you can use from a &lt;em&gt;lot&lt;/em&gt; of editors, including VS Code, Atom, Sublime Text, and the JetBrains IDEs‚Äîwill actually give you the correct completion when you start definition a type. So imagine we were defining some other union type elsewhere in our program to handle events. Now we can use the same &lt;code&gt;UnionKeyToValue&lt;/code&gt; type to construct this type, with immediate, &lt;em&gt;correct&lt;/em&gt; feedback from the TypeScript language service:&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt; &lt;source type='video/mp4' src='http://cdn.chriskrycho.com/images/completion.mp4'&gt; &lt;/video&gt;
&lt;figcaption&gt;
TypeScript live code completion of the mapped type
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;By inverting our original approach of using &lt;code&gt;keyof&lt;/code&gt; (itself powerful and worth using in quite a few circumstances) and instead using the new mapped types, we get a &lt;em&gt;ton&lt;/em&gt; of mileage in terms of productivity when using these types‚Äîerrors prevented, and speed of writing the code in the first place increased as well.&lt;/p&gt;
&lt;p&gt;Yes, it‚Äôs a little verbose and it does require duplicating the strings whenever you define one of these types.&lt;a href="#fn7" class="footnoteRef" id="fnref7"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; But, and this is what I find most important: there is only one &lt;em&gt;source&lt;/em&gt; for those string keys, the union type, and it is definitive. If you change that central union type, everything else that references it, including the namespace-like object, will fail to compile until you make the same change there.&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt; &lt;source type='video/mp4' src='http://cdn.chriskrycho.com/images/change-union.mp4'&gt; &lt;/video&gt;
&lt;figcaption&gt;
Updating a union
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So it‚Äôs a lot more work than it would be in, say, Elm. But it‚Äôs also a lot more guarantees than I‚Äôd get in plain-old-JavaScript, or even TypeScript two months ago.&lt;/p&gt;
&lt;p&gt;I‚Äôll call that a win.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;it‚Äôs no surprise that Microsoft‚Äôs developer tooling is stronger than Facebook‚Äôs&lt;a href="#fnref1"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;along with all the other ML-descended languages I‚Äôve played with, including Haskell, F&lt;sup&gt;‚ôØ&lt;/sup&gt;, PureScript, and Elm.&lt;a href="#fnref2"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Aside: to be extra safe and prevent any confusion or mucking around, you should probably call &lt;code&gt;Object.freeze()&lt;/code&gt; on the object literal, too:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = Object.freeze({
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both convention and linters make it unlikely you‚Äôll modify something like this directly‚Äîbut impossible is better than unlikely.&lt;a href="#fnref3"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Flow has supported this feature for some time; you can write &lt;code&gt;$Keys&amp;lt;typeof STATE&amp;gt;&lt;/code&gt;‚Äîbut the feature is entirely undocumented.&lt;a href="#fnref4"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Set your &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; key in your &lt;code&gt;tsconfig.json&lt;/code&gt; to include &lt;code&gt;&amp;quot;noEmitOnError&amp;quot;: true,&lt;/code&gt;.&lt;a href="#fnref5"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;For namespacing in a more general sense, you should use‚Ä¶ &lt;a href="http://www.typescriptlang.org/docs/handbook/namespaces.html"&gt;namespaces&lt;/a&gt;.&lt;a href="#fnref6"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7"&gt;&lt;p&gt;It would be great if we could get these benefits without the duplication‚Äîmaybe someday we‚Äôll have better support in JS or TS natively.&lt;a href="#fnref7"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 17 Dec 2016 23:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-17:/2016/keyof-and-mapped-types-in-typescript-21.html</guid><category>javascript</category><category>typescript</category><category>software development</category><category>programming languages</category></item></channel></rss>